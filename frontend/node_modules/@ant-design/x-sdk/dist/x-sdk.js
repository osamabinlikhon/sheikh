((__TURBOPACK__) => {
            
if (!Array.isArray(__TURBOPACK__)) {
    return;
}

const CHUNK_BASE_PATH = "";
const CHUNK_SUFFIX_PATH = "";
const RELATIVE_ROOT_PATH = "/ROOT";
const RUNTIME_PUBLIC_PATH = "";
/**
 * This file contains runtime types and functions that are shared between all
 * TurboPack ECMAScript runtimes.
 *
 * It will be prepended to the runtime code of each runtime.
 */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path="./runtime-types.d.ts" />
const REEXPORTED_OBJECTS = Symbol("reexported objects");
/**
 * Constructs the `__turbopack_context__` object for a module.
 */ function Context(module) {
    this.m = module;
    this.e = module.exports;
}
const contextPrototype = Context.prototype;
const hasOwnProperty = Object.prototype.hasOwnProperty;
const toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag;
function defineProp(obj, name, options) {
    if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options);
}
function getOverwrittenModule(moduleCache, id) {
    let module = moduleCache[id];
    if (!module) {
        // This is invoked when a module is merged into another module, thus it wasn't invoked via
        // instantiateModule and the cache entry wasn't created yet.
        module = createModuleObject(id);
        moduleCache[id] = module;
    }
    return module;
}
/**
 * Creates the module object. Only done here to ensure all module objects have the same shape.
 */ function createModuleObject(id) {
    return {
        exports: {},
        error: undefined,
        loaded: false,
        id,
        namespaceObject: undefined,
        [REEXPORTED_OBJECTS]: undefined
    };
}
/**
 * Adds the getters to the exports object.
 */ function esm(exports, getters) {
    defineProp(exports, "__esModule", {
        value: true
    });
    if (toStringTag) defineProp(exports, toStringTag, {
        value: "Module"
    });
    for(const key in getters){
        const item = getters[key];
        if (Array.isArray(item)) {
            defineProp(exports, key, {
                get: item[0],
                set: item[1],
                enumerable: true
            });
        } else {
            defineProp(exports, key, {
                get: item,
                enumerable: true
            });
        }
    }
    Object.seal(exports);
}
/**
 * Makes the module an ESM with exports
 */ function esmExport(getters, id) {
    let module = this.m;
    let exports = this.e;
    if (id != null) {
        module = getOverwrittenModule(this.c, id);
        exports = module.exports;
    }
    module.namespaceObject = module.exports;
    esm(exports, getters);
}
contextPrototype.s = esmExport;
function ensureDynamicExports(module, exports) {
    let reexportedObjects = module[REEXPORTED_OBJECTS];
    if (!reexportedObjects) {
        reexportedObjects = module[REEXPORTED_OBJECTS] = [];
        module.exports = module.namespaceObject = new Proxy(exports, {
            get (target, prop) {
                if (hasOwnProperty.call(target, prop) || prop === "default" || prop === "__esModule") {
                    return Reflect.get(target, prop);
                }
                for (const obj of reexportedObjects){
                    const value = Reflect.get(obj, prop);
                    if (value !== undefined) return value;
                }
                return undefined;
            },
            ownKeys (target) {
                const keys = Reflect.ownKeys(target);
                for (const obj of reexportedObjects){
                    for (const key of Reflect.ownKeys(obj)){
                        if (key !== "default" && !keys.includes(key)) keys.push(key);
                    }
                }
                return keys;
            }
        });
    }
}
/**
 * Dynamically exports properties from an object
 */ function dynamicExport(object, id) {
    let module = this.m;
    let exports = this.e;
    if (id != null) {
        module = getOverwrittenModule(this.c, id);
        exports = module.exports;
    }
    ensureDynamicExports(module, exports);
    if (typeof object === "object" && object !== null) {
        module[REEXPORTED_OBJECTS].push(object);
    }
}
contextPrototype.j = dynamicExport;
function exportValue(value, id) {
    let module = this.m;
    if (id != null) {
        module = getOverwrittenModule(this.c, id);
    }
    module.exports = value;
}
contextPrototype.v = exportValue;
function exportNamespace(namespace, id) {
    let module = this.m;
    if (id != null) {
        module = getOverwrittenModule(this.c, id);
    }
    module.exports = module.namespaceObject = namespace;
}
contextPrototype.n = exportNamespace;
function createGetter(obj, key) {
    return ()=>obj[key];
}
/**
 * @returns prototype of the object
 */ const getProto = Object.getPrototypeOf ? (obj)=>Object.getPrototypeOf(obj) : (obj)=>obj.__proto__;
/** Prototypes that are not expanded for exports */ const LEAF_PROTOTYPES = [
    null,
    getProto({}),
    getProto([]),
    getProto(getProto)
];
/**
 * @param raw
 * @param ns
 * @param allowExportDefault
 *   * `false`: will have the raw module as default export
 *   * `true`: will have the default property as default export
 */ function interopEsm(raw, ns, allowExportDefault) {
    const getters = Object.create(null);
    for(let current = raw; (typeof current === "object" || typeof current === "function") && !LEAF_PROTOTYPES.includes(current); current = getProto(current)){
        for (const key of Object.getOwnPropertyNames(current)){
            getters[key] = createGetter(raw, key);
        }
    }
    // this is not really correct
    // we should set the `default` getter if the imported module is a `.cjs file`
    if (!(allowExportDefault && "default" in getters)) {
        getters["default"] = ()=>raw;
    }
    esm(ns, getters);
    return ns;
}
function createNS(raw) {
    if (typeof raw === "function") {
        return function(...args) {
            return raw.apply(this, args);
        };
    } else {
        return Object.create(null);
    }
}
function esmImport(id) {
    const module = getOrInstantiateModuleFromParent(id, this.m);
    if (module.error) throw module.error;
    // any ES module has to have `module.namespaceObject` defined.
    if (module.namespaceObject) return module.namespaceObject;
    // only ESM can be an async module, so we don't need to worry about exports being a promise here.
    const raw = module.exports;
    return module.namespaceObject = interopEsm(raw, createNS(raw), raw && raw.__esModule);
}
contextPrototype.i = esmImport;
function asyncLoader(moduleId) {
    const loader = this.r(moduleId);
    return loader(this.i.bind(this));
}
contextPrototype.A = asyncLoader;
// Add a simple runtime require so that environments without one can still pass
// `typeof require` CommonJS checks so that exports are correctly registered.
const runtimeRequire = // @ts-ignore
typeof require === "function" ? require : function require1() {
    throw new Error("Unexpected use of runtime require");
};
contextPrototype.t = runtimeRequire;
function commonJsRequire(id) {
    const module = getOrInstantiateModuleFromParent(id, this.m);
    if (module.error) throw module.error;
    return module.exports;
}
contextPrototype.r = commonJsRequire;
/**
 * `require.context` and require/import expression runtime.
 */ function moduleContext(map) {
    function moduleContext(id) {
        if (hasOwnProperty.call(map, id)) {
            return map[id].module();
        }
        const e = new Error(`Cannot find module '${id}'`);
        e.code = "MODULE_NOT_FOUND";
        throw e;
    }
    moduleContext.keys = ()=>{
        return Object.keys(map);
    };
    moduleContext.resolve = (id)=>{
        if (hasOwnProperty.call(map, id)) {
            return map[id].id();
        }
        const e = new Error(`Cannot find module '${id}'`);
        e.code = "MODULE_NOT_FOUND";
        throw e;
    };
    moduleContext.import = async (id)=>{
        return await moduleContext(id);
    };
    return moduleContext;
}
contextPrototype.f = moduleContext;
/**
 * Returns the path of a chunk defined by its data.
 */ function getChunkPath(chunkData) {
    return typeof chunkData === "string" ? chunkData : chunkData.path;
}
function isPromise(maybePromise) {
    return maybePromise != null && typeof maybePromise === "object" && "then" in maybePromise && typeof maybePromise.then === "function";
}
function isAsyncModuleExt(obj) {
    return turbopackQueues in obj;
}
function createPromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        reject = rej;
        resolve = res;
    });
    return {
        promise,
        resolve: resolve,
        reject: reject
    };
}
// everything below is adapted from webpack
// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13
const turbopackQueues = Symbol("turbopack queues");
const turbopackExports = Symbol("turbopack exports");
const turbopackError = Symbol("turbopack error");
function resolveQueue(queue) {
    if (queue && queue.status !== 1) {
        queue.status = 1;
        queue.forEach((fn)=>fn.queueCount--);
        queue.forEach((fn)=>fn.queueCount-- ? fn.queueCount++ : fn());
    }
}
function wrapDeps(deps) {
    return deps.map((dep)=>{
        if (dep !== null && typeof dep === "object") {
            if (isAsyncModuleExt(dep)) return dep;
            if (isPromise(dep)) {
                const queue = Object.assign([], {
                    status: 0
                });
                const obj = {
                    [turbopackExports]: {},
                    [turbopackQueues]: (fn)=>fn(queue)
                };
                dep.then((res)=>{
                    obj[turbopackExports] = res;
                    resolveQueue(queue);
                }, (err)=>{
                    obj[turbopackError] = err;
                    resolveQueue(queue);
                });
                return obj;
            }
        }
        return {
            [turbopackExports]: dep,
            [turbopackQueues]: ()=>{}
        };
    });
}
function asyncModule(body, hasAwait) {
    const module = this.m;
    const queue = hasAwait ? Object.assign([], {
        status: -1
    }) : undefined;
    const depQueues = new Set();
    const { resolve, reject, promise: rawPromise } = createPromise();
    const promise = Object.assign(rawPromise, {
        [turbopackExports]: module.exports,
        [turbopackQueues]: (fn)=>{
            queue && fn(queue);
            depQueues.forEach(fn);
            promise["catch"](()=>{});
        }
    });
    const attributes = {
        get () {
            return promise;
        },
        set (v) {
            // Calling `esmExport` leads to this.
            if (v !== promise) {
                promise[turbopackExports] = v;
            }
        }
    };
    Object.defineProperty(module, "exports", attributes);
    Object.defineProperty(module, "namespaceObject", attributes);
    function handleAsyncDependencies(deps) {
        const currentDeps = wrapDeps(deps);
        const getResult = ()=>currentDeps.map((d)=>{
                if (d[turbopackError]) throw d[turbopackError];
                return d[turbopackExports];
            });
        const { promise, resolve } = createPromise();
        const fn = Object.assign(()=>resolve(getResult), {
            queueCount: 0
        });
        function fnQueue(q) {
            if (q !== queue && !depQueues.has(q)) {
                depQueues.add(q);
                if (q && q.status === 0) {
                    fn.queueCount++;
                    q.push(fn);
                }
            }
        }
        currentDeps.map((dep)=>dep[turbopackQueues](fnQueue));
        return fn.queueCount ? promise : getResult();
    }
    function asyncResult(err) {
        if (err) {
            reject(promise[turbopackError] = err);
        } else {
            resolve(promise[turbopackExports]);
        }
        resolveQueue(queue);
    }
    body(handleAsyncDependencies, asyncResult);
    if (queue && queue.status === -1) {
        queue.status = 0;
    }
}
contextPrototype.a = asyncModule;
/**
 * A pseudo "fake" URL object to resolve to its relative path.
 *
 * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this
 * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid
 * hydration mismatch.
 *
 * This is based on webpack's existing implementation:
 * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js
 */ const relativeURL = function relativeURL(inputUrl) {
    const realUrl = new URL(inputUrl, "x:/");
    const values = {};
    for(const key in realUrl)values[key] = realUrl[key];
    values.href = inputUrl;
    values.pathname = inputUrl.replace(/[?#].*/, "");
    values.origin = values.protocol = "";
    values.toString = values.toJSON = (..._args)=>inputUrl;
    for(const key in values)Object.defineProperty(this, key, {
        enumerable: true,
        configurable: true,
        value: values[key]
    });
};
relativeURL.prototype = URL.prototype;
contextPrototype.U = relativeURL;
/**
 * Utility function to ensure all variants of an enum are handled.
 */ function invariant(never, computeMessage) {
    throw new Error(`Invariant: ${computeMessage(never)}`);
}
/**
 * A stub function to make `require` available but non-functional in ESM.
 */ function requireStub(_moduleId) {
    throw new Error("dynamic usage of require is not supported");
}
contextPrototype.z = requireStub;
/**
 * This file contains runtime types and functions that are shared between all
 * Turbopack *development* ECMAScript runtimes.
 *
 * It will be appended to the runtime code of each runtime right after the
 * shared runtime utils.
 */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path="./globals.d.ts" />
/// <reference path="./runtime-utils.ts" />
// Used in WebWorkers to tell the runtime about the chunk base path
const browserContextPrototype = Context.prototype;
var SourceType = /*#__PURE__*/ function(SourceType) {
    /**
   * The module was instantiated because it was included in an evaluated chunk's
   * runtime.
   * SourceData is a ChunkPath.
   */ SourceType[SourceType["Runtime"] = 0] = "Runtime";
    /**
   * The module was instantiated because a parent module imported it.
   * SourceData is a ModuleId.
   */ SourceType[SourceType["Parent"] = 1] = "Parent";
    /**
   * The module was instantiated because it was included in a chunk's hot module
   * update.
   * SourceData is an array of ModuleIds or undefined.
   */ SourceType[SourceType["Update"] = 2] = "Update";
    return SourceType;
}(SourceType || {});
const moduleFactories = Object.create(null);
contextPrototype.M = moduleFactories;
const availableModules = new Map();
const availableModuleChunks = new Map();
function factoryNotAvailable(moduleId, sourceType, sourceData) {
    let instantiationReason;
    switch(sourceType){
        case 0:
            instantiationReason = `as a runtime entry of chunk ${sourceData}`;
            break;
        case 1:
            instantiationReason = `because it was required from module ${sourceData}`;
            break;
        case 2:
            instantiationReason = "because of an HMR update";
            break;
        default:
            invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);
    }
    throw new Error(`Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`);
}
const loadedChunk = Promise.resolve(undefined);
const instrumentedBackendLoadChunks = new WeakMap();
// Do not make this async. React relies on referential equality of the returned Promise.
function loadChunkByUrl(chunkUrl) {
    return loadChunkByUrlInternal(1, this.m.id, chunkUrl);
}
browserContextPrototype.L = loadChunkByUrl;
// Do not make this async. React relies on referential equality of the returned Promise.
function loadChunkByUrlInternal(sourceType, sourceData, chunkUrl) {
    const thenable = BACKEND.loadChunkCached(sourceType, sourceData, chunkUrl);
    let entry = instrumentedBackendLoadChunks.get(thenable);
    if (entry === undefined) {
        const resolve = instrumentedBackendLoadChunks.set.bind(instrumentedBackendLoadChunks, thenable, loadedChunk);
        entry = thenable.then(resolve).catch((error)=>{
            let loadReason;
            switch(sourceType){
                case 0:
                    loadReason = `as a runtime dependency of chunk ${sourceData}`;
                    break;
                case 1:
                    loadReason = `from module ${sourceData}`;
                    break;
                case 2:
                    loadReason = "from an HMR update";
                    break;
                default:
                    invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);
            }
            throw new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${error ? `: ${error}` : ""}`, error ? {
                cause: error
            } : undefined);
        });
        instrumentedBackendLoadChunks.set(thenable, entry);
    }
    return entry;
}
// Do not make this async. React relies on referential equality of the returned Promise.
function loadChunkPath(sourceType, sourceData, chunkPath) {
    const url = getChunkRelativeUrl(chunkPath);
    return loadChunkByUrlInternal(sourceType, sourceData, url);
}
/**
 * Returns an absolute url to an asset.
 */ function resolvePathFromModule(moduleId) {
    const exported = this.r(moduleId);
    return exported?.default ?? exported;
}
browserContextPrototype.R = resolvePathFromModule;
/**
 * no-op for browser
 * @param modulePath
 */ function resolveAbsolutePath(modulePath) {
    return `/ROOT/${modulePath ?? ""}`;
}
browserContextPrototype.P = resolveAbsolutePath;
/**
 * Instantiates a runtime module.
 */ function instantiateRuntimeModule(moduleId, chunkPath) {
    return instantiateModule(moduleId, 0, chunkPath);
}
/**
 * Returns the URL relative to the origin where a chunk can be fetched from.
 */ function getChunkRelativeUrl(chunkPath) {
    return `${CHUNK_BASE_PATH}${chunkPath.split("/").map((p)=>encodeURIComponent(p)).join("/")}${CHUNK_SUFFIX_PATH}`;
}
function getPathFromScript(chunkScript) {
    if (typeof chunkScript === "string") {
        return chunkScript;
    }
    const chunkUrl = typeof TURBOPACK_NEXT_CHUNK_URLS !== "undefined" ? TURBOPACK_NEXT_CHUNK_URLS.pop() : chunkScript.getAttribute("src");
    const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ""));
    let path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;
    if (path.startsWith("/")) {
        path = path.slice(1);
    }
    return path;
}
function registerCompressedModuleFactory(moduleId, moduleFactory) {
    if (!moduleFactories[moduleId]) {
        if (Array.isArray(moduleFactory)) {
            let [moduleFactoryFn, otherIds] = moduleFactory;
            moduleFactories[moduleId] = moduleFactoryFn;
            for (const otherModuleId of otherIds){
                moduleFactories[otherModuleId] = moduleFactoryFn;
            }
        } else {
            moduleFactories[moduleId] = moduleFactory;
        }
    }
}
const regexJsUrl = /\.js(?:\?[^#]*)?(?:#.*)?$/;
/**
 * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.
 */ function isJs(chunkUrlOrPath) {
    return regexJsUrl.test(chunkUrlOrPath);
}
/// <reference path="./runtime-base.ts" />
/// <reference path="./dummy.ts" />
const moduleCache = {};
contextPrototype.c = moduleCache;
/**
 * Gets or instantiates a runtime module.
 */ // @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getOrInstantiateRuntimeModule(chunkPath, moduleId) {
    const module = moduleCache[moduleId];
    if (module) {
        if (module.error) {
            throw module.error;
        }
        return module;
    }
    return instantiateModule(moduleId, SourceType.Runtime, chunkPath);
}
/**
 * Retrieves a module from the cache, or instantiate it if it is not cached.
 */ // Used by the backend
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const getOrInstantiateModuleFromParent = (id, sourceModule)=>{
    const module = moduleCache[id];
    if (module) {
        return module;
    }
    return instantiateModule(id, SourceType.Parent, sourceModule.id);
};
function instantiateModule(id, sourceType, sourceData) {
    const moduleFactory = moduleFactories[id];
    if (typeof moduleFactory !== "function") {
        // This can happen if modules incorrectly handle HMR disposes/updates,
        // e.g. when they keep a `setTimeout` around which still executes old code
        // and contains e.g. a `require("something")` call.
        factoryNotAvailable(id, sourceType, sourceData);
    }
    const module = createModuleObject(id);
    moduleCache[id] = module;
    // NOTE(alexkirsz) This can fail when the module encounters a runtime error.
    try {
        const context = new Context(module);
        moduleFactory(context);
    } catch (error) {
        module.error = error;
        throw error;
    }
    module.loaded = true;
    if (module.namespaceObject && module.exports !== module.namespaceObject) {
        // in case of a circular dependency: cjs1 -> esm2 -> cjs1
        interopEsm(module.exports, module.namespaceObject);
    }
    return module;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function registerChunk([chunkScript, chunkModules, runtimeParams]) {
    const chunkPath = getPathFromScript(chunkScript);
    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)){
        registerCompressedModuleFactory(moduleId, moduleFactory);
    }
    return BACKEND.registerChunk(chunkPath, runtimeParams);
}
/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path="./runtime-utils.ts" />
/// A 'base' utilities to support runtime can have externals.
/// Currently this is for node.js / edge runtime both.
/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.
async function externalImport(id) {
    let raw;
    try {
        raw = await import(id);
    } catch (err) {
        // TODO(alexkirsz) This can happen when a client-side module tries to load
        // an external module we don't provide a shim for (e.g. querystring, url).
        // For now, we fail semi-silently, but in the future this should be a
        // compilation error.
        throw new Error(`Failed to load external module ${id}: ${err}`);
    }
    if (raw && raw.__esModule && raw.default && "default" in raw.default) {
        return interopEsm(raw.default, createNS(raw), true);
    }
    return raw;
}
contextPrototype.y = externalImport;
function externalRequire(id, thunk, esm = false) {
    let raw;
    try {
        raw = thunk();
    } catch (err) {
        // TODO(alexkirsz) This can happen when a client-side module tries to load
        // an external module we don't provide a shim for (e.g. querystring, url).
        // For now, we fail semi-silently, but in the future this should be a
        // compilation error.
        throw new Error(`Failed to load external module ${id}: ${err}`);
    }
    if (!esm || raw.__esModule) {
        return raw;
    }
    return interopEsm(raw, createNS(raw), true);
}
externalRequire.resolve = (id, options)=>{
    return require.resolve(id, options);
};
contextPrototype.x = externalRequire;
/**
 * This file contains the runtime code specific to the Turbopack development
 * ECMAScript DOM runtime.
 *
 * It will be appended to the base development runtime code.
 */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path="./runtime-base.ts" />
/// <reference path="./runtime-types.d.ts" />
let BACKEND;
/**
 * Maps chunk paths to the corresponding resolver.
 */ const chunkResolvers = new Map();
(()=>{
    BACKEND = {
        registerChunk (chunkPath, params) {
            const chunkUrl = getChunkRelativeUrl(chunkPath);
            const resolver = getOrCreateResolver(chunkUrl);
            resolver.resolve();
            if (params == null) {
                return;
            }
            for (const otherChunkData of params.otherChunks){
                const otherChunkPath = getChunkPath(otherChunkData);
                const otherChunkUrl = getChunkRelativeUrl(otherChunkPath);
                // Chunk might have started loading, so we want to avoid triggering another load.
                getOrCreateResolver(otherChunkUrl);
            }
            if (params.runtimeModuleIds.length > 0) {
                for (const moduleId of params.runtimeModuleIds){
                    getOrInstantiateRuntimeModule(chunkPath, moduleId);
                }
            }
        },
        /**
     * Loads the given chunk, and returns a promise that resolves once the chunk
     * has been loaded.
     */ loadChunkCached (sourceType, sourceData, chunkUrl) {
            return doLoadChunk(sourceType, sourceData, chunkUrl);
        }
    };
    function getOrCreateResolver(chunkUrl) {
        let resolver = chunkResolvers.get(chunkUrl);
        if (!resolver) {
            let resolve;
            let reject;
            const promise = new Promise((innerResolve, innerReject)=>{
                resolve = innerResolve;
                reject = innerReject;
            });
            resolver = {
                resolved: false,
                loadingStarted: false,
                promise,
                resolve: ()=>{
                    resolver.resolved = true;
                    resolve();
                },
                reject: reject
            };
            chunkResolvers.set(chunkUrl, resolver);
        }
        return resolver;
    }
    /**
   * Loads the given chunk, and returns a promise that resolves once the chunk
   * has been loaded.
   */ function doLoadChunk(sourceType, _sourceData, chunkUrl) {
        const resolver = getOrCreateResolver(chunkUrl);
        if (resolver.loadingStarted) {
            return resolver.promise;
        }
        if (sourceType === SourceType.Runtime) {
            // We don't need to load chunks references from runtime code, as they're already
            // present in the DOM.
            resolver.loadingStarted = true;
            // We need to wait for JS chunks to register themselves within `registerChunk`
            // before we can start instantiating runtime modules, hence the absence of
            // `resolver.resolve()` in this branch.
            return resolver.promise;
        }
        if (typeof importScripts === "function") {
            // We're in a web worker
            if (isJs(chunkUrl)) {
                self.TURBOPACK_NEXT_CHUNK_URLS.push(chunkUrl);
                importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);
            } else {
                throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);
            }
        } else {
            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.
            const decodedChunkUrl = decodeURI(chunkUrl);
            if (isJs(chunkUrl)) {
                const previousScripts = document.querySelectorAll(`script[src="${chunkUrl}"],script[src^="${chunkUrl}?"],script[src="${decodedChunkUrl}"],script[src^="${decodedChunkUrl}?"]`);
                if (previousScripts.length > 0) {
                    // There is this edge where the script already failed loading, but we
                    // can't detect that. The Promise will never resolve in this case.
                    for (const script of Array.from(previousScripts)){
                        script.addEventListener("error", ()=>{
                            resolver.reject();
                        });
                    }
                } else {
                    const script = document.createElement("script");
                    script.src = chunkUrl;
                    // We'll only mark the chunk as loaded once the script has been executed,
                    // which happens in `registerChunk`. Hence the absence of `resolve()` in
                    // this branch.
                    script.onerror = ()=>{
                        resolver.reject();
                    };
                    // Append to the `head` for webpack compatibility.
                    document.head.appendChild(script);
                }
            } else {
                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);
            }
        }
        resolver.loadingStarted = true;
        return resolver.promise;
    }
})();
const chunksToRegister = __TURBOPACK__;
__TURBOPACK__ = { push: registerChunk };
chunksToRegister.forEach(registerChunk);
function factory () {
    const runtimeModuleIds = ["643"];
    if (runtimeModuleIds.length > 0) {
        const module = moduleCache[runtimeModuleIds[0]];
        if (module.error) throw module.error;
        // any ES module has to have `module.namespaceObject` defined.
        if (module.namespaceObject) return module.namespaceObject;
        // only ESM can be an async module, so we don't need to worry about exports being a promise here.
        const raw = module.exports;
        return module.namespaceObject = interopEsm(raw, createNS(raw), raw && raw.__esModule);
    }
}

if (typeof exports === 'object' && typeof module === 'object') {
    module.exports = factory();
} else if (typeof exports === 'object') {
    exports["XSDK"] = factory();
} else {
    globalThis["XSDK"] = factory();
}
})([["x-sdk.js", {

571: ((__turbopack_context__) => {
"use strict";

let mod; if (typeof exports === 'object' && typeof module === 'object') { mod = __turbopack_context__.x("react", () => require("react")); } else { mod = globalThis["React"] }

__turbopack_context__.v(mod);
}),
652: ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(a) {
    if ("object" === typeof a && null !== a) {
        var r = a.$$typeof;
        switch(r){
            case b:
                switch(a = a.type, a){
                    case d:
                    case f:
                    case e:
                    case m:
                    case n:
                        return a;
                    default:
                        switch(a = a && a.$$typeof, a){
                            case k:
                            case h:
                            case l:
                            case q:
                            case p:
                            case g:
                                return a;
                            default:
                                return r;
                        }
                }
            case c:
                return r;
        }
    }
}
exports.ContextConsumer = h;
exports.ContextProvider = g;
exports.Element = b;
exports.ForwardRef = l;
exports.Fragment = d;
exports.Lazy = q;
exports.Memo = p;
exports.Portal = c;
exports.Profiler = f;
exports.StrictMode = e;
exports.Suspense = m;
exports.SuspenseList = n;
exports.isAsyncMode = function() {
    return !1;
};
exports.isConcurrentMode = function() {
    return !1;
};
exports.isContextConsumer = function(a) {
    return v(a) === h;
};
exports.isContextProvider = function(a) {
    return v(a) === g;
};
exports.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
};
exports.isForwardRef = function(a) {
    return v(a) === l;
};
exports.isFragment = function(a) {
    return v(a) === d;
};
exports.isLazy = function(a) {
    return v(a) === q;
};
exports.isMemo = function(a) {
    return v(a) === p;
};
exports.isPortal = function(a) {
    return v(a) === c;
};
exports.isProfiler = function(a) {
    return v(a) === f;
};
exports.isStrictMode = function(a) {
    return v(a) === e;
};
exports.isSuspense = function(a) {
    return v(a) === m;
};
exports.isSuspenseList = function(a) {
    return v(a) === n;
};
exports.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? !0 : !1;
};
exports.typeOf = v;
}),
24: ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time truthy", 1) {
    module.exports = __turbopack_context__.r(652);
} else //TURBOPACK unreachable
;
}),
643: ((__turbopack_context__) => {
"use strict";

// MERGED MODULE: [project]/packages/x-sdk/src/index.ts [library] (ecmascript)
;
// MERGED MODULE: [project]/packages/x-sdk/src/index.ts [library] (ecmascript) <locals>
;
;
;
;
;
;
__turbopack_context__.s([], 584);
var __TURBOPACK__imported__module__584__ = __turbopack_context__.i(584);
// MERGED MODULE: [project]/packages/x-sdk/src/chat-providers/index.ts [library] (ecmascript)
;
// MERGED MODULE: [project]/packages/x-sdk/src/chat-providers/index.ts [library] (ecmascript) <locals>
;
;
;
;
;
__turbopack_context__.s([], 469);
var __TURBOPACK__imported__module__469__ = __turbopack_context__.i(469);
// MERGED MODULE: [project]/packages/x-sdk/src/chat-providers/AbstractChatProvider.ts [library] (ecmascript)
;
class AbstractChatProvider {
    _request;
    _getMessagesFn;
    _originalCallbacks;
    get request() {
        return this._request;
    }
    constructor(config){
        const request = typeof config.request === 'function' ? config.request() : config.request;
        if (!request.manual) {
            throw new Error('request must be manual');
        }
        this._request = request;
        this._originalCallbacks = this._request.options?.callbacks;
    }
    getMessages() {
        return this?._getMessagesFn();
    }
    injectGetMessages(getMessages) {
        this._getMessagesFn = getMessages;
    }
    injectRequest({ onUpdate, onSuccess, onError }) {
        const originalOnUpdate = this._originalCallbacks?.onUpdate;
        const originalOnSuccess = this._originalCallbacks?.onSuccess;
        const originalOnError = this._originalCallbacks?.onError;
        this._request.options.callbacks = {
            onUpdate: (data, responseHeaders)=>{
                const msg = onUpdate(data, responseHeaders);
                if (originalOnUpdate) originalOnUpdate(data, responseHeaders, msg);
            },
            onSuccess: (data, responseHeaders)=>{
                const msg = onSuccess(data, responseHeaders);
                if (originalOnSuccess) originalOnSuccess(data, responseHeaders, msg);
            },
            onError: (error, errorInfo, responseHeaders)=>{
                const fallbackMsg = onError(error, errorInfo);
                if (originalOnError) originalOnError(error, errorInfo, responseHeaders, fallbackMsg);
            }
        };
    }
}
// MERGED MODULE: [project]/packages/x-sdk/src/chat-providers/DeepSeekChatProvider.ts [library] (ecmascript)
;
;
class DeepSeekChatProvider extends AbstractChatProvider {
    transformParams(requestParams, options) {
        return {
            ...options?.params || {},
            ...requestParams,
            messages: this.getMessages()
        };
    }
    transformLocalMessage(requestParams) {
        return requestParams?.messages || [];
    }
    transformMessage(info) {
        const { originMessage, chunk, responseHeaders } = info;
        let currentContent = '';
        let currentThink = '';
        let role = 'assistant';
        try {
            let message;
            if (responseHeaders.get('content-type')?.includes('text/event-stream')) {
                if (chunk && chunk.data?.trim() !== '[DONE]') {
                    message = JSON.parse(chunk.data);
                }
            } else {
                message = chunk;
            }
            if (message) {
                message?.choices?.forEach((choice)=>{
                    if (choice?.delta) {
                        currentThink = choice.delta.reasoning_content || '';
                        currentContent += choice.delta.content || '';
                        role = choice.delta.role;
                    } else if (choice?.message) {
                        currentThink = choice.message.reasoning_content || '';
                        currentContent += choice.message.content || '';
                        role = choice.message.role;
                    }
                });
            }
        } catch (error) {
            console.error('transformMessage error', error);
        }
        let content = '';
        let originMessageContent = typeof originMessage?.content === 'string' ? originMessage?.content : originMessage?.content.text || '';
        if (!originMessageContent && currentThink) {
            // 仅匹配最多前两个换行符，避免性能问题
            content = `\n\n<think>\n\n${currentThink?.replace?.(/^\n{0,2}/, '')}`;
        } else if (originMessageContent.includes('<think>') && !originMessageContent.includes('</think>') && currentContent) {
            originMessageContent = originMessageContent.replace('<think>', '<think status="done">');
            // 仅匹配最多结尾的两个空白字符和换行符
            content = `${originMessageContent?.replace?.(/[\s\n]{0,2}$/, '')}\n\n</think>\n\n${currentContent}`;
        } else {
            content = `${originMessageContent || ''}${currentThink}${currentContent}`;
        }
        return {
            content,
            role: role || 'assistant'
        };
    }
}
// MERGED MODULE: [project]/packages/x-sdk/src/chat-providers/DefaultChatProvider.ts [library] (ecmascript)
;
;
class DefaultChatProvider extends AbstractChatProvider {
    transformParams(requestParams, options) {
        if (typeof requestParams !== 'object') {
            throw new Error('requestParams must be an object');
        }
        return {
            ...options?.params || {},
            ...requestParams || {}
        };
    }
    transformLocalMessage(requestParams) {
        return requestParams;
    }
    transformMessage(info) {
        const { chunk, chunks, originMessage } = info;
        if (chunk) {
            return chunk;
        }
        if (Array.isArray(chunks)) {
            const chunk = chunks?.length > 0 ? chunks?.[chunks?.length - 1] : undefined;
            return originMessage ? originMessage : chunk;
        }
        return chunks;
    }
}
// MERGED MODULE: [project]/packages/x-sdk/src/chat-providers/OpenAIChatProvider.ts [library] (ecmascript)
;
;
class OpenAIChatProvider extends AbstractChatProvider {
    transformParams(requestParams, options) {
        return {
            ...options?.params || {},
            ...requestParams,
            messages: this.getMessages()
        };
    }
    transformLocalMessage(requestParams) {
        return requestParams?.messages || [];
    }
    transformMessage(info) {
        const { originMessage, chunk, responseHeaders } = info;
        let currentContent = '';
        let role = 'assistant';
        try {
            let message;
            if (responseHeaders.get('content-type')?.includes('text/event-stream')) {
                if (chunk && chunk.data?.trim() !== '[DONE]') {
                    message = JSON.parse(chunk.data);
                }
            } else {
                message = chunk;
            }
            if (message) {
                message?.choices?.forEach((choice)=>{
                    if (choice?.delta) {
                        currentContent += choice.delta.content || '';
                        role = choice.delta.role || 'assistant';
                    } else if (choice?.message) {
                        currentContent += choice.message.content || '';
                        role = choice.message.role || 'assistant';
                    }
                });
            }
        } catch (error) {
            console.error('transformMessage error', error);
        }
        const content = `${originMessage?.content || ''}${currentContent || ''}`;
        return {
            content,
            role
        };
    }
}
__turbopack_context__.s([
    "AbstractChatProvider",
    ()=>AbstractChatProvider,
    "DeepSeekChatProvider",
    ()=>DeepSeekChatProvider,
    "DefaultChatProvider",
    ()=>DefaultChatProvider,
    "OpenAIChatProvider",
    ()=>OpenAIChatProvider
], 297);
var __TURBOPACK__imported__module__297__ = __turbopack_context__.i(297);
// MERGED MODULE: [project]/packages/x-sdk/src/x-chat/index.ts [library] (ecmascript)
;
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/index.js [library] (ecmascript) <locals>
;
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/hooks/useEvent.js [library] (ecmascript)
;
/* eslint-disable @typescript-eslint/ban-types */ /* eslint-disable react-hooks/exhaustive-deps */ var __TURBOPACK__imported__module__571__ = __turbopack_context__.i(571);
;
function useEvent(callback) {
    const fnRef = __TURBOPACK__imported__module__571__["useRef"](callback);
    fnRef.current = callback;
    const memoFn = __TURBOPACK__imported__module__571__["useCallback"]((...args)=>fnRef.current?.(...args), []);
    return memoFn;
}
var __TURBOPACK__default__export__ = useEvent;
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/hooks/useMergedState.js [library] (ecmascript)
;
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/hooks/useLayoutEffect.js [library] (ecmascript)
;
var __TURBOPACK__imported__module__571__1 = __TURBOPACK__imported__module__571__;
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/Dom/canUseDom.js [library] (ecmascript)
;
function canUseDom() {
    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}
;
;
/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */ const useInternalLayoutEffect = ("TURBOPACK simplified expression", canUseDom()) ? __TURBOPACK__imported__module__571__1["useLayoutEffect"] : __TURBOPACK__imported__module__571__1["useEffect"];
const useLayoutEffect = (callback, deps)=>{
    const firstMountRef = __TURBOPACK__imported__module__571__1["useRef"](true);
    useInternalLayoutEffect(()=>{
        return callback(firstMountRef.current);
    }, deps);
    // We tell react that first mount has passed
    useInternalLayoutEffect(()=>{
        firstMountRef.current = false;
        return ()=>{
            firstMountRef.current = true;
        };
    }, []);
};
const useLayoutUpdateEffect = (callback, deps)=>{
    useLayoutEffect((firstMount)=>{
        if (!firstMount) {
            return callback();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
};
var __TURBOPACK__default__export__1 = useLayoutEffect;
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/hooks/useState.js [library] (ecmascript)
;
var __TURBOPACK__imported__module__571__2 = __TURBOPACK__imported__module__571__;
;
/**
 * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
 * We do not make this auto is to avoid real memory leak.
 * Developer should confirm it's safe to ignore themselves.
 */ const useSafeState = (defaultValue)=>{
    const destroyRef = __TURBOPACK__imported__module__571__2["useRef"](false);
    const [value, setValue] = __TURBOPACK__imported__module__571__2["useState"](defaultValue);
    __TURBOPACK__imported__module__571__2["useEffect"](()=>{
        destroyRef.current = false;
        return ()=>{
            destroyRef.current = true;
        };
    }, []);
    function safeSetState(updater, ignoreDestroy) {
        if (ignoreDestroy && destroyRef.current) {
            return;
        }
        setValue(updater);
    }
    return [
        value,
        safeSetState
    ];
};
var __TURBOPACK__default__export__2 = useSafeState;
;
;
;
/** We only think `undefined` is empty */ function hasValue(value) {
    return value !== undefined;
}
function useMergedState(defaultStateValue, option) {
    const { defaultValue, value, onChange, postState } = option || {};
    // ======================= Init =======================
    const [innerValue, setInnerValue] = __TURBOPACK__default__export__2(()=>{
        if (hasValue(value)) {
            return value;
        } else if (hasValue(defaultValue)) {
            return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
        } else {
            return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
        }
    });
    const mergedValue = value !== undefined ? value : innerValue;
    const postMergedValue = postState ? postState(mergedValue) : mergedValue;
    // ====================== Change ======================
    const onChangeFn = __TURBOPACK__default__export__(onChange);
    const [prevValue, setPrevValue] = __TURBOPACK__default__export__2([
        mergedValue
    ]);
    useLayoutUpdateEffect(()=>{
        const prev = prevValue[0];
        if (innerValue !== prev) {
            onChangeFn(innerValue, prev);
        }
    }, [
        prevValue
    ]);
    // Sync value back to `undefined` when it from control to un-control
    useLayoutUpdateEffect(()=>{
        if (!hasValue(value)) {
            setInnerValue(value);
        }
    }, [
        value
    ]);
    // ====================== Update ======================
    const triggerChange = __TURBOPACK__default__export__((updater, ignoreDestroy)=>{
        setInnerValue(updater, ignoreDestroy);
        setPrevValue([
            mergedValue
        ], ignoreDestroy);
    });
    return [
        postMergedValue,
        triggerChange
    ];
}
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/hooks/useControlledState.js [library] (ecmascript)
;
var __TURBOPACK__imported__module__571__3 = __TURBOPACK__imported__module__571__;
;
;
function useControlledState(defaultStateValue, value) {
    const [innerValue, setInnerValue] = (0, __TURBOPACK__imported__module__571__3["useState"])(defaultStateValue);
    const mergedValue = value !== undefined ? value : innerValue;
    __TURBOPACK__default__export__1((mount)=>{
        if (!mount) {
            setInnerValue(value);
        }
    }, [
        value
    ]);
    return [
        // Value
        mergedValue,
        // Update function
        setInnerValue
    ];
}
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/ref.js [library] (ecmascript)
;
var __TURBOPACK__imported__module__571__4 = __TURBOPACK__imported__module__571__;
var __TURBOPACK__imported__module__24__ = __turbopack_context__.i(24);
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/hooks/useMemo.js [library] (ecmascript)
;
var __TURBOPACK__imported__module__571__5 = __TURBOPACK__imported__module__571__;
;
function useMemo(getValue, condition, shouldUpdate) {
    const cacheRef = __TURBOPACK__imported__module__571__5["useRef"]({});
    if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue();
        cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
}
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/React/isFragment.js [library] (ecmascript)
;
const REACT_ELEMENT_TYPE_18 = Symbol.for('react.element');
const REACT_ELEMENT_TYPE_19 = Symbol.for('react.transitional.element');
const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
function isFragment(object) {
    return(// Base object type
    object && typeof object === 'object' && (// React Element type
    object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) && // React Fragment type
    object.type === REACT_FRAGMENT_TYPE);
}
;
;
;
;
const ReactMajorVersion = Number(__TURBOPACK__imported__module__571__4["version"].split('.')[0]);
const fillRef = (ref, node)=>{
    if (typeof ref === 'function') {
        ref(node);
    } else if (typeof ref === 'object' && ref && 'current' in ref) {
        ref.current = node;
    }
};
const composeRef = (...refs)=>{
    const refList = refs.filter(Boolean);
    if (refList.length <= 1) {
        return refList[0];
    }
    return (node)=>{
        refs.forEach((ref)=>{
            fillRef(ref, node);
        });
    };
};
const useComposeRef = (...refs)=>{
    return useMemo(()=>composeRef(...refs), // eslint-disable-next-line react-hooks/exhaustive-deps
    refs, (prev, next)=>prev.length !== next.length || prev.every((ref, i)=>ref !== next[i]));
};
const supportRef = (nodeOrComponent)=>{
    if (!nodeOrComponent) {
        return false;
    }
    // React 19 no need `forwardRef` anymore. So just pass if is a React element.
    if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) {
        return true;
    }
    const type = (0, __TURBOPACK__imported__module__24__["isMemo"])(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
    // Function component node
    if (typeof type === 'function' && !type.prototype?.render && type.$$typeof !== __TURBOPACK__imported__module__24__["ForwardRef"]) {
        return false;
    }
    // Class component
    if (typeof nodeOrComponent === 'function' && !nodeOrComponent.prototype?.render && nodeOrComponent.$$typeof !== __TURBOPACK__imported__module__24__["ForwardRef"]) {
        return false;
    }
    return true;
};
function isReactElement(node) {
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__571__4["isValidElement"])(node) && !isFragment(node);
}
const supportNodeRef = (node)=>{
    return isReactElement(node) && supportRef(node);
};
const getNodeRef = (node)=>{
    if (node && isReactElement(node)) {
        const ele = node;
        // Source from:
        // https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/getReactNodeRef/getReactNodeRef.ts
        return ele.props.propertyIsEnumerable('ref') ? ele.props.ref : ele.ref;
    }
    return null;
};
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/utils/get.js [library] (ecmascript)
;
function get(entity, path) {
    let current = entity;
    for(let i = 0; i < path.length; i += 1){
        if (current === null || current === undefined) {
            return undefined;
        }
        current = current[path[i]];
    }
    return current;
}
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/utils/set.js [library] (ecmascript)
;
;
function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) {
        return value;
    }
    const [path, ...restPath] = paths;
    let clone;
    if (!entity && typeof path === 'number') {
        clone = [];
    } else if (Array.isArray(entity)) {
        clone = [
            ...entity
        ];
    } else {
        clone = {
            ...entity
        };
    }
    // Delete prop if `removeIfUndefined` and value is undefined
    if (removeIfUndefined && value === undefined && restPath.length === 1) {
        delete clone[path][restPath[0]];
    } else {
        clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
    }
    return clone;
}
function set(entity, paths, value, removeIfUndefined = false) {
    // Do nothing if `removeIfUndefined` and parent object not exist
    if (paths.length && removeIfUndefined && value === undefined && !get(entity, paths.slice(0, -1))) {
        return entity;
    }
    return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
    return Array.isArray(source) ? [] : {};
}
const keys = typeof Reflect === 'undefined' ? Object.keys : Reflect.ownKeys;
function mergeWith(sources, config = {}) {
    const { prepareArray } = config;
    const finalPrepareArray = prepareArray || (()=>[]);
    let clone = createEmpty(sources[0]);
    sources.forEach((src)=>{
        function internalMerge(path, parentLoopSet) {
            const loopSet = new Set(parentLoopSet);
            const value = get(src, path);
            const isArr = Array.isArray(value);
            if (isArr || isObject(value)) {
                // Only add not loop obj
                if (!loopSet.has(value)) {
                    loopSet.add(value);
                    const originValue = get(clone, path);
                    if (isArr) {
                        // Array will always be override
                        clone = set(clone, path, finalPrepareArray(originValue, value));
                    } else if (!originValue || typeof originValue !== 'object') {
                        // Init container if not exist
                        clone = set(clone, path, createEmpty(value));
                    }
                    keys(value).forEach((key)=>{
                        if (Object.getOwnPropertyDescriptor(value, key).enumerable) {
                            internalMerge([
                                ...path,
                                key
                            ], loopSet);
                        }
                    });
                }
            } else {
                clone = set(clone, path, value);
            }
        }
        internalMerge([]);
    });
    return clone;
}
function merge(...sources) {
    return mergeWith(sources);
}
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/warning.js [library] (ecmascript)
;
/* eslint-disable no-console */ let warned = {};
const preWarningFns = [];
const preMessage = (fn)=>{
    preWarningFns.push(fn);
};
function warning(valid, message) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
}
function note(valid, message) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
}
function resetWarned() {
    warned = {};
}
function call(method, valid, message) {
    if (!valid && !warned[message]) {
        method(false, message);
        warned[message] = true;
    }
}
function warningOnce(valid, message) {
    call(warning, valid, message);
}
function noteOnce(valid, message) {
    call(note, valid, message);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
var __TURBOPACK__default__export__3 = warningOnce;
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/omit.js [library] (ecmascript)
;
function omit(obj, fields) {
    const clone = Object.assign({}, obj);
    if (Array.isArray(fields)) {
        fields.forEach((key)=>{
            delete clone[key];
        });
    }
    return clone;
}
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/Children/toArray.js [library] (ecmascript)
;
var __TURBOPACK__imported__module__571__6 = __TURBOPACK__imported__module__571__;
;
;
function toArray(children, option = {}) {
    let ret = [];
    __TURBOPACK__imported__module__571__6["default"].Children.forEach(children, (child)=>{
        if ((child === undefined || child === null) && !option.keepEmpty) {
            return;
        }
        if (Array.isArray(child)) {
            ret = ret.concat(toArray(child));
        } else if (isFragment(child) && child.props) {
            ret = ret.concat(toArray(child.props.children, option));
        } else {
            ret.push(child);
        }
    });
    return ret;
}
;
;
;
;
;
;
;
;
;
// MERGED MODULE: [project]/node_modules/@rc-component/util/es/hooks/useEvent.js [library] (ecmascript) <export default as useEvent>
;
var __TURBOPACK__imported__module__571__7 = __TURBOPACK__imported__module__571__;
// MERGED MODULE: [project]/packages/x-sdk/src/x-chat/store.ts [library] (ecmascript)
;
var __TURBOPACK__imported__module__571__8 = __TURBOPACK__imported__module__571__;
;
const chatMessagesStoreHelper = {
    _chatMessagesStores: new Map(),
    get: (conversationKey)=>{
        return chatMessagesStoreHelper._chatMessagesStores.get(conversationKey);
    },
    set: (key, store)=>{
        chatMessagesStoreHelper._chatMessagesStores.set(key, store);
    },
    delete: (key)=>{
        chatMessagesStoreHelper._chatMessagesStores.delete(key);
    },
    getMessages: (conversationKey)=>{
        const store = chatMessagesStoreHelper._chatMessagesStores.get(conversationKey);
        return store?.getMessages();
    }
};
class ChatMessagesStore {
    listeners = [];
    conversationKey;
    snapshotResult = {
        messages: [],
        isDefaultMessagesRequesting: false
    };
    // Throttle state for preventing "Maximum update depth exceeded" during streaming
    throttleTimer = null;
    pendingEmit = false;
    throttleInterval = 50;
    // 竞态条件保护
    isDestroyed = false;
    emitListeners() {
        this.listeners.forEach((listener)=>{
            listener();
        });
    }
    throttledEmitListeners() {
        if (!this.throttleTimer) {
            // Leading edge: execute immediately
            this.emitListeners();
            this.pendingEmit = false;
            this.throttleTimer = setTimeout(()=>{
                this.throttleTimer = null;
                // Trailing edge: flush pending updates
                if (this.pendingEmit) {
                    this.emitListeners();
                    this.pendingEmit = false;
                }
            }, this.throttleInterval);
        } else {
            this.pendingEmit = true;
        }
    }
    constructor(defaultMessages, conversationKey){
        // 初始化消息，处理同步和异步情况
        this.initializeMessages(defaultMessages, (value)=>{
            this.setSnapshotResult('isDefaultMessagesRequesting', value);
            this.emitListeners();
        });
        // 注册到全局存储助手
        if (conversationKey) {
            this.conversationKey = conversationKey;
            chatMessagesStoreHelper.set(this.conversationKey, this);
        }
    }
    async initializeMessages(defaultMessages, setDefaultMessagesRequesting) {
        try {
            setDefaultMessagesRequesting(true);
            const messages = await defaultMessages();
            // 检查是否已被销毁，避免竞态条件
            if (!this.isDestroyed) {
                this.setMessagesInternal(messages, false);
            }
        } catch (error) {
            // 错误处理：保持空数组状态，避免应用崩溃
            console.warn('Failed to initialize messages:', error);
            if (!this.isDestroyed) {
                this.setMessagesInternal([], false);
            }
        } finally{
            setDefaultMessagesRequesting(false);
        }
    }
    setSnapshotResult = (key, value)=>{
        this.snapshotResult = {
            ...this.snapshotResult,
            [key]: value
        };
    };
    setMessagesInternal = (messages, throttle = true)=>{
        let list;
        if (typeof messages === 'function') {
            list = messages(this.snapshotResult.messages);
        } else {
            list = messages;
        }
        this.setSnapshotResult('messages', list);
        if (throttle) {
            this.throttledEmitListeners();
        } else {
            this.emitListeners();
        }
        return true;
    };
    setMessages = (messages)=>{
        return this.setMessagesInternal(messages, true);
    };
    getMessages = ()=>{
        return this.snapshotResult.messages;
    };
    getMessage = (id)=>{
        return this.getMessages().find((item)=>item.id === id);
    };
    addMessage = (message)=>{
        const exist = this.getMessage(message.id);
        if (!exist) {
            this.setMessages([
                ...this.snapshotResult.messages,
                message
            ]);
            return true;
        }
        return false;
    };
    setMessage = (id, message)=>{
        const originMessage = this.getMessage(id);
        if (originMessage) {
            const mergeMessage = typeof message === 'function' ? message(originMessage) : message;
            Object.assign(originMessage, mergeMessage);
            this.setMessages([
                ...this.snapshotResult.messages
            ]);
            return true;
        }
        return false;
    };
    removeMessage = (id)=>{
        const index = this.getMessages().findIndex((item)=>item.id === id);
        if (index !== -1) {
            this.snapshotResult.messages.splice(index, 1);
            this.setMessages([
                ...this.getMessages()
            ]);
            return true;
        }
        return false;
    };
    getSnapshot = ()=>{
        return this.snapshotResult;
    };
    subscribe = (callback)=>{
        this.listeners.push(callback);
        return ()=>{
            this.listeners = this.listeners.filter((listener)=>listener !== callback);
            // Clean up throttle timer when no listeners remain to prevent memory leaks
            // and "setState on unmounted component" warnings
            if (this.listeners.length === 0) {
                if (this.throttleTimer) {
                    clearTimeout(this.throttleTimer);
                    this.throttleTimer = null;
                }
                this.pendingEmit = false;
            }
        };
    };
    /**
   * Clean up resources (throttle timer) when the store is no longer needed.
   * Should be called when the component unmounts or the store is disposed.
   */ destroy = ()=>{
        this.isDestroyed = true;
        if (this.throttleTimer) {
            clearTimeout(this.throttleTimer);
            this.throttleTimer = null;
        }
        this.pendingEmit = false;
        this.listeners = [];
    };
}
function useChatStore(defaultValue, conversationKey) {
    const createStore = ()=>{
        if (chatMessagesStoreHelper.get(conversationKey)) {
            return chatMessagesStoreHelper.get(conversationKey);
        }
        const store = new ChatMessagesStore(defaultValue, conversationKey);
        return store;
    };
    const [store, setStore] = (0, __TURBOPACK__imported__module__571__8["useState"])(createStore);
    (0, __TURBOPACK__imported__module__571__8["useEffect"])(()=>{
        setStore(createStore());
    }, [
        conversationKey
    ]);
    const { messages, isDefaultMessagesRequesting } = (0, __TURBOPACK__imported__module__571__8["useSyncExternalStore"])(store.subscribe, store.getSnapshot, store.getSnapshot);
    return {
        messages,
        isDefaultMessagesRequesting,
        addMessage: store.addMessage,
        removeMessage: store.removeMessage,
        setMessage: store.setMessage,
        getMessage: store.getMessage,
        setMessages: store.setMessages,
        getMessages: store.getMessages
    };
}
;
;
;
var MessageStatusEnum = function(MessageStatusEnum) {
    MessageStatusEnum["local"] = "local";
    MessageStatusEnum["loading"] = "loading";
    MessageStatusEnum["updating"] = "updating";
    MessageStatusEnum["success"] = "success";
    MessageStatusEnum["error"] = "error";
    MessageStatusEnum["abort"] = "abort";
    return MessageStatusEnum;
}(MessageStatusEnum || {});
function toArray1(item) {
    return Array.isArray(item) ? item : [
        item
    ];
}
const IsRequestingMap = new Map();
const generateConversationKey = ()=>Symbol('ConversationKey');
function useXChat(config) {
    const { defaultMessages, requestFallback, requestPlaceholder, parser, provider, conversationKey: originalConversationKey } = config;
    // ========================= Agent Messages =========================
    const idRef = __TURBOPACK__imported__module__571__7["default"].useRef(0);
    const requestHandlerRef = __TURBOPACK__imported__module__571__7["default"].useRef(undefined);
    const [isRequesting, setIsRequesting] = (0, __TURBOPACK__imported__module__571__7["useState"])(false);
    // fix #1431, should give a default key to create store
    const [conversationKey, setConversationKey] = (0, __TURBOPACK__imported__module__571__7["useState"])(originalConversationKey || generateConversationKey());
    (0, __TURBOPACK__imported__module__571__7["useEffect"])(()=>{
        if (originalConversationKey) {
            setConversationKey(originalConversationKey);
        }
    }, [
        originalConversationKey
    ]);
    const { messages, isDefaultMessagesRequesting, removeMessage, setMessages, getMessages, setMessage } = useChatStore(async ()=>{
        const messageList = typeof defaultMessages === 'function' ? await defaultMessages({
            conversationKey: originalConversationKey
        }) : defaultMessages;
        return (messageList || []).map((info, index)=>({
                id: `default_${index}`,
                status: 'local',
                ...info
            }));
    }, conversationKey);
    const createMessage = (message, status, extraInfo)=>{
        const msg = {
            id: `msg_${idRef.current}`,
            message,
            status
        };
        if (extraInfo) {
            msg.extraInfo = extraInfo;
        }
        idRef.current += 1;
        return msg;
    };
    // ========================= BubbleMessages =========================
    const parsedMessages = __TURBOPACK__imported__module__571__7["default"].useMemo(()=>{
        const list = [];
        messages.forEach((agentMsg)=>{
            const rawParsedMsg = parser ? parser(agentMsg.message) : agentMsg.message;
            const bubbleMsgs = toArray1(rawParsedMsg);
            bubbleMsgs.forEach((bubbleMsg, bubbleMsgIndex)=>{
                let key = agentMsg.id;
                if (bubbleMsgs.length > 1) {
                    key = `${key}_${bubbleMsgIndex}`;
                }
                list.push({
                    id: key,
                    message: bubbleMsg,
                    status: agentMsg.status
                });
            });
        });
        return list;
    }, [
        messages
    ]);
    // ============================ Request =============================
    const getFilteredMessages = (msgs)=>msgs.filter((info)=>info.status !== 'loading').map((info)=>info.message);
    provider?.injectGetMessages(()=>{
        return getFilteredMessages(getMessages());
    });
    requestHandlerRef.current = provider?.request;
    // For agent to use. Will filter out loading and error message
    const getRequestMessages = ()=>getFilteredMessages(getMessages());
    const innerOnRequest = (requestParams, opts)=>{
        if (!provider) {
            return;
        }
        const { updatingId, reload } = opts || {};
        let loadingMsgId = null;
        const localMessage = provider.transformLocalMessage(requestParams);
        const messages = (Array.isArray(localMessage) ? localMessage : [
            localMessage
        ]).map((message)=>createMessage(message, 'local', opts?.extraInfo));
        if (reload) {
            loadingMsgId = updatingId;
            setMessages((ori)=>{
                const nextMessages = [
                    ...ori
                ];
                if (requestPlaceholder) {
                    let placeholderMsg;
                    if (typeof requestPlaceholder === 'function') {
                        // typescript has bug that not get real return type when use `typeof function` check
                        placeholderMsg = requestPlaceholder(requestParams, {
                            messages: getFilteredMessages(nextMessages)
                        });
                    } else {
                        placeholderMsg = requestPlaceholder;
                    }
                    nextMessages.forEach((info)=>{
                        if (info.id === updatingId) {
                            info.status = 'loading';
                            info.message = placeholderMsg;
                            if (opts?.extraInfo) {
                                info.extraInfo = opts?.extraInfo;
                            }
                        }
                    });
                }
                return nextMessages;
            });
        } else {
            // Add placeholder message
            setMessages((ori)=>{
                let nextMessages = [
                    ...ori,
                    ...messages
                ];
                if (requestPlaceholder) {
                    let placeholderMsg;
                    if (typeof requestPlaceholder === 'function') {
                        // typescript has bug that not get real return type when use `typeof function` check
                        placeholderMsg = requestPlaceholder(requestParams, {
                            messages: getFilteredMessages(nextMessages)
                        });
                    } else {
                        placeholderMsg = requestPlaceholder;
                    }
                    const loadingMsg = createMessage(placeholderMsg, 'loading');
                    loadingMsgId = loadingMsg.id;
                    nextMessages = [
                        ...nextMessages,
                        loadingMsg
                    ];
                }
                return nextMessages;
            });
        }
        // Request
        let updatingMsgId = null;
        const updateMessage = (status, chunk, chunks, responseHeaders)=>{
            let msg = getMessages().find((info)=>info.id === updatingMsgId);
            if (!msg) {
                if (reload && updatingId) {
                    msg = getMessages().find((info)=>info.id === updatingId);
                    if (msg) {
                        msg.status = status;
                        msg.message = provider.transformMessage({
                            chunk,
                            status,
                            chunks,
                            responseHeaders
                        });
                        setMessages((ori)=>{
                            return [
                                ...ori
                            ];
                        });
                        updatingMsgId = msg.id;
                    }
                } else {
                    // Create if not exist
                    const transformData = provider.transformMessage({
                        chunk,
                        status,
                        chunks,
                        responseHeaders
                    });
                    msg = createMessage(transformData, status);
                    setMessages((ori)=>{
                        const oriWithoutPending = ori.filter((info)=>info.id !== loadingMsgId);
                        return [
                            ...oriWithoutPending,
                            msg
                        ];
                    });
                    updatingMsgId = msg.id;
                }
            } else {
                // Update directly
                setMessages((ori)=>{
                    return ori.map((info)=>{
                        if (info.id === updatingMsgId) {
                            const transformData = provider.transformMessage({
                                originMessage: info.message,
                                chunk,
                                chunks,
                                status,
                                responseHeaders
                            });
                            return {
                                ...info,
                                message: transformData,
                                status
                            };
                        }
                        return info;
                    });
                });
            }
            msg = getMessages().find((info)=>info.id === updatingMsgId) || msg;
            return msg;
        };
        provider.injectRequest({
            onUpdate: (chunk, headers)=>{
                const msg = updateMessage('updating', chunk, [], headers);
                return msg;
            },
            onSuccess: (chunks, headers)=>{
                setIsRequesting(false);
                conversationKey && IsRequestingMap.delete(conversationKey);
                const msg = updateMessage('success', undefined, chunks, headers);
                return msg;
            },
            onError: async (error, errorInfo)=>{
                setIsRequesting(false);
                conversationKey && IsRequestingMap.delete(conversationKey);
                let fallbackMsg;
                if (requestFallback) {
                    // Update as error
                    if (typeof requestFallback === 'function') {
                        // typescript has bug that not get real return type when use `typeof function` check
                        const messages = getRequestMessages();
                        const msg = getMessages().find((info)=>info.id === loadingMsgId || info.id === updatingMsgId);
                        fallbackMsg = await requestFallback(requestParams, {
                            error,
                            errorInfo,
                            messageInfo: msg,
                            messages
                        });
                    } else {
                        fallbackMsg = requestFallback;
                    }
                    setMessages((ori)=>[
                            ...ori.filter((info)=>info.id !== loadingMsgId && info.id !== updatingMsgId),
                            createMessage(fallbackMsg, error.name === 'AbortError' ? 'abort' : 'error')
                        ]);
                } else {
                    // Remove directly
                    fallbackMsg = getMessages().find((info)=>info.id !== loadingMsgId && info.id !== updatingMsgId);
                    setMessages((ori)=>{
                        return ori.map((info)=>{
                            if (info.id === loadingMsgId || info.id === updatingMsgId) {
                                return {
                                    ...info,
                                    status: error.name === 'AbortError' ? 'abort' : 'error'
                                };
                            }
                            return info;
                        });
                    });
                }
                return fallbackMsg;
            }
        });
        setIsRequesting(true);
        conversationKey && IsRequestingMap.set(conversationKey, true);
        provider.request.run(provider.transformParams(requestParams, provider.request.options));
    };
    const onRequest = __TURBOPACK__default__export__((requestParams, opts)=>{
        if (!provider) {
            throw new Error('provider is required');
        }
        innerOnRequest(requestParams, opts);
    });
    const onReload = (id, requestParams, opts)=>{
        if (!provider) {
            throw new Error('provider is required');
        }
        if (!id || !getMessages().find((info)=>info.id === id)) {
            throw new Error(`message [${id}] is not found`);
        }
        innerOnRequest(requestParams, {
            updatingId: id,
            reload: true,
            extraInfo: opts?.extraInfo
        });
    };
    return {
        onRequest,
        isDefaultMessagesRequesting,
        messages,
        parsedMessages,
        setMessages,
        removeMessage,
        setMessage,
        abort: ()=>{
            if (!provider) {
                throw new Error('provider is required');
            }
            requestHandlerRef.current?.abort();
        },
        isRequesting: conversationKey ? IsRequestingMap?.get(conversationKey) || false : isRequesting,
        onReload
    };
}
// MERGED MODULE: [project]/packages/x-sdk/src/x-conversations/index.ts [library] (ecmascript)
;
var __TURBOPACK__imported__module__571__9 = __TURBOPACK__imported__module__571__;
// MERGED MODULE: [project]/packages/x-sdk/src/x-conversations/store.ts [library] (ecmascript)
;
;
const conversationStoreHelper = {
    _allConversationStores: new Map(),
    set: (key, store)=>{
        conversationStoreHelper._allConversationStores.set(key, store);
    },
    delete: (key)=>{
        conversationStoreHelper._allConversationStores.delete(key);
    },
    getConversation: (conversationKey)=>{
        for (const store of conversationStoreHelper._allConversationStores.values()){
            if (store) {
                const conversation = store.getConversation(conversationKey);
                if (conversation) {
                    return conversation;
                }
            }
        }
    }
};
class ConversationStore {
    conversations = [];
    listeners = [];
    storeKey;
    activeConversationKey;
    emitListeners() {
        this.listeners.forEach((listener)=>{
            listener();
        });
    }
    constructor(defaultConversations, defaultActiveConversationKey){
        this.setConversations(defaultConversations);
        this.storeKey = Math.random().toString();
        conversationStoreHelper.set(this.storeKey, this);
        this.activeConversationKey = defaultActiveConversationKey;
    }
    setActiveConversationKey = (key)=>{
        this.activeConversationKey = key;
        this.emitListeners();
        return true;
    };
    setConversations = (list)=>{
        this.conversations = [
            ...list
        ];
        this.emitListeners();
        return true;
    };
    getConversation = (key)=>{
        return this.conversations.find((item)=>item.key === key);
    };
    addConversation = (conversation, placement)=>{
        const exist = this.getConversation(conversation.key);
        if (!exist) {
            this.setConversations(placement === 'prepend' ? [
                conversation,
                ...this.conversations
            ] : [
                ...this.conversations,
                conversation
            ]);
            return true;
        }
        return false;
    };
    setConversation = (key, conversation)=>{
        const exist = this.getConversation(key);
        if (exist) {
            Object.assign(exist, conversation);
            this.setConversations([
                ...this.conversations
            ]);
            return true;
        }
        return false;
    };
    removeConversation = (key)=>{
        const index = this.conversations.findIndex((item)=>item.key === key);
        if (index !== -1) {
            this.conversations.splice(index, 1);
            this.setConversations([
                ...this.conversations
            ]);
            return true;
        }
        return false;
    };
    getMessages = (key)=>{
        return chatMessagesStoreHelper.getMessages(key);
    };
    getSnapshot = ()=>{
        return this.conversations;
    };
    getActiveConversationKey = ()=>{
        return this.activeConversationKey;
    };
    subscribe = (callback)=>{
        this.listeners.push(callback);
        return ()=>{
            this.listeners = this.listeners.filter((listener)=>listener !== callback);
        };
    };
    destroy = ()=>{
        conversationStoreHelper.delete(this.storeKey);
    };
}
;
;
function useXConversations(config) {
    const [store] = (0, __TURBOPACK__imported__module__571__9["useState"])(()=>{
        const store = new ConversationStore(config?.defaultConversations || [], config?.defaultActiveConversationKey || '');
        return store;
    });
    (0, __TURBOPACK__imported__module__571__9["useEffect"])(()=>{
        return ()=>{
            store.destroy();
        };
    }, []);
    const conversations = (0, __TURBOPACK__imported__module__571__9["useSyncExternalStore"])(store.subscribe, store.getSnapshot, store.getSnapshot);
    const activeConversationKey = (0, __TURBOPACK__imported__module__571__9["useSyncExternalStore"])(store.subscribe, store.getActiveConversationKey, store.getActiveConversationKey);
    return {
        conversations,
        activeConversationKey: activeConversationKey,
        setActiveConversationKey: store.setActiveConversationKey,
        addConversation: store.addConversation,
        removeConversation: store.removeConversation,
        setConversation: store.setConversation,
        getConversation: store.getConversation,
        setConversations: store.setConversations,
        getMessages: store.getMessages
    };
}
// MERGED MODULE: [project]/packages/x-sdk/src/x-request/index.ts [library] (ecmascript)
;
// MERGED MODULE: [project]/packages/x-sdk/src/x-stream/index.ts [library] (ecmascript)
;
/**
 * @description default separator for {@link splitStream}
 */ const DEFAULT_STREAM_SEPARATOR = '\n\n';
/**
 * @description Default separator for {@link splitPart}
 * @example "event: delta\ndata: {\"key\": \"value\"}"
 */ const DEFAULT_PART_SEPARATOR = '\n';
/**
 * @description Default separator for key value, A colon (`:`) is used to separate keys from values
 * @example "event: delta"
 */ const DEFAULT_KV_SEPARATOR = ':';
/**
 * Check if a string is not empty or only contains whitespace characters
 */ const isValidString = (str)=>(str ?? '').trim() !== '';
/**
 * @description A TransformStream inst that splits a stream into parts based on {@link DEFAULT_STREAM_SEPARATOR}
 * @example
 *
 * `event: delta
 * data: { content: 'hello' }
 *
 * event: delta
 * data: { key: 'world!' }
 *
 * `
 */ function splitStream(streamSeparator = DEFAULT_STREAM_SEPARATOR) {
    // Buffer to store incomplete data chunks between transformations
    let buffer = '';
    return new TransformStream({
        transform (streamChunk, controller) {
            buffer += streamChunk;
            // Split the buffer based on the separator
            const parts = buffer.split(streamSeparator);
            // Enqueue all complete parts except for the last incomplete one
            parts.slice(0, -1).forEach((part)=>{
                // Skip empty parts
                if (isValidString(part)) {
                    controller.enqueue(part);
                }
            });
            // Save the last incomplete part back to the buffer for the next chunk
            buffer = parts[parts.length - 1];
        },
        flush (controller) {
            // If there's any remaining data in the buffer, enqueue it as the final part
            if (isValidString(buffer)) {
                controller.enqueue(buffer);
            }
        }
    });
}
/**
 * @description A TransformStream inst that transforms a part string into {@link SSEOutput}
 * @example part string
 *
 * "event: delta\ndata: { key: 'world!' }\n"
 *
 * @link https://developer.mozilla.org/en-US/docs/Web/API/EventSource
 *
 * When handling responses with `Content-Type: text/event-stream`, the following standard practices are commonly observed:
 * - Double newline characters (`\n\n`) are used to separate individual events.
 * - Single newline characters (`\n`) are employed to separate line within an event.
 */ function splitPart(partSeparator = DEFAULT_PART_SEPARATOR, kvSeparator = DEFAULT_KV_SEPARATOR) {
    return new TransformStream({
        transform (partChunk, controller) {
            // Split the chunk into key-value pairs using the partSeparator
            const lines = partChunk.split(partSeparator);
            const sseEvent = lines.reduce((acc, line)=>{
                const separatorIndex = line.indexOf(kvSeparator);
                if (separatorIndex === -1) {
                    console.warn(`The key-value separator "${kvSeparator}" is not found in the sse line: ${line} !`);
                    return acc;
                }
                // Extract the key from the beginning of the line up to the separator
                const key = line.slice(0, separatorIndex).trim();
                // The colon is used for comment lines, skip directly
                if (!isValidString(key)) return acc;
                // Extract the value from the line after the separator
                const value = line.slice(separatorIndex + 1).trim();
                return {
                    ...acc,
                    [key]: value
                };
            }, {});
            if (Object.keys(sseEvent).length === 0) return;
            // Reduce the key-value pairs into a single object and enqueue
            controller.enqueue(sseEvent);
        }
    });
}
function createDecoderStream() {
    if (typeof TextDecoderStream !== 'undefined') {
        return new TextDecoderStream();
    }
    const decoder = new TextDecoder('utf-8');
    return new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(decoder.decode(chunk, {
                stream: true
            }));
        },
        flush (controller) {
            controller.enqueue(decoder.decode());
        }
    });
}
/**
 * @description Transform Uint8Array binary stream to {@link SSEOutput} by default
 * @warning The `XStream` only support the `utf-8` encoding. More encoding support maybe in the future.
 */ function XStream(options) {
    const { readableStream, transformStream, streamSeparator, partSeparator, kvSeparator } = options;
    if (!(readableStream instanceof ReadableStream)) {
        throw new Error('The options.readableStream must be an instance of ReadableStream.');
    }
    // Default encoding is `utf-8`
    const decoderStream = createDecoderStream();
    const stream = transformStream ? /**
         * Uint8Array binary -> string -> Output
         */ readableStream.pipeThrough(decoderStream).pipeThrough(transformStream) : /**
         * Uint8Array binary -> string -> SSE part string -> Default Output {@link SSEOutput}
         */ readableStream.pipeThrough(decoderStream).pipeThrough(splitStream(streamSeparator)).pipeThrough(splitPart(partSeparator, kvSeparator));
    /** support async iterator */ stream[Symbol.asyncIterator] = async function*() {
        const reader = this.getReader();
        while(true){
            const { done, value } = await reader.read();
            if (done) break;
            if (!value) continue;
            // Transformed data through all transform pipes
            yield value;
        }
    };
    return stream;
}
var __TURBOPACK__default__export__4 = XStream;
// MERGED MODULE: [project]/packages/x-sdk/src/x-request/x-fetch.ts [library] (ecmascript)
;
const XFetch = async (baseURL, options)=>{
    const { fetch: fetchFn = globalThis.fetch, middlewares = {}, ...requestInit } = options;
    if (typeof fetchFn !== 'function') {
        throw new Error('The options.fetch must be a typeof fetch function!');
    }
    /** ---------------------- request init ---------------------- */ let fetchArgs = [
        baseURL,
        requestInit
    ];
    /** ---------------------- request middleware ---------------------- */ if (typeof middlewares.onRequest === 'function') {
        const modifiedFetchArgs = await middlewares.onRequest(...fetchArgs);
        fetchArgs = modifiedFetchArgs;
    }
    /** ---------------------- fetch ---------------------- */ let response = await fetchFn(...fetchArgs);
    /** ---------------------- response middleware ---------------------- */ if (typeof middlewares.onResponse === 'function') {
        const modifiedResponse = await middlewares.onResponse(response);
        if (!(modifiedResponse instanceof Response)) {
            throw new Error('The options.onResponse must return a Response instance!');
        }
        response = modifiedResponse;
    }
    /** ---------------------- response check ---------------------- */ if (!response.ok) {
        throw new Error(`Fetch failed with status ${response.status}`);
    }
    if (!response.body) {
        throw new Error('The response body is empty.');
    }
    /** ---------------------- return ---------------------- */ return response;
};
var __TURBOPACK__default__export__5 = XFetch;
;
;
/**
 * @description Global options for the request
 */ const globalOptions = {
    manual: false,
    headers: {
        'Content-Type': 'application/json'
    }
};
function setXRequestGlobalOptions(options) {
    Object.assign(globalOptions, options);
}
const LastEventId = 'Last-Event-ID';
class AbstractXRequestClass {
    baseURL;
    options;
    constructor(baseURL, options){
        if (!baseURL || typeof baseURL !== 'string') throw new Error('The baseURL is not valid!');
        this.baseURL = baseURL;
        this.options = options || {};
    }
}
class XRequestClass extends AbstractXRequestClass {
    _asyncHandler;
    timeoutHandler;
    _isTimeout = false;
    streamTimeoutHandler;
    _isStreamTimeout = false;
    abortController;
    _isRequesting = false;
    _manual = false;
    lastManualParams;
    retryTimes = 0;
    retryTimer;
    lastEventId = undefined;
    get asyncHandler() {
        return this._asyncHandler;
    }
    get isTimeout() {
        return this._isTimeout;
    }
    set isTimeout(value) {
        this._isTimeout = value;
    }
    get isStreamTimeout() {
        return this._isStreamTimeout;
    }
    set isStreamTimeout(value) {
        this._isStreamTimeout = value;
    }
    get isRequesting() {
        return this._isRequesting;
    }
    get manual() {
        return this._manual;
    }
    constructor(baseURL, options){
        super(baseURL, options);
        this._manual = options?.manual || false;
        if (!this.manual) {
            this.init();
        }
    }
    run(params) {
        if (this.manual) {
            this.resetRetry();
            this.lastManualParams = params;
            this.init(params);
            return true;
        }
        console.warn('The request is not manual, so it cannot be run!');
        return false;
    }
    abort() {
        clearTimeout(this.timeoutHandler);
        clearTimeout(this.streamTimeoutHandler);
        this.abortController.abort();
    }
    init(extraParams, extraHeaders) {
        this.abortController = new AbortController();
        const { callbacks, params, headers = {}, transformStream, fetch, timeout, streamTimeout, middlewares, streamSeparator, partSeparator, kvSeparator, ...otherOptions } = this.options;
        const margeHeaders = Object.assign({}, globalOptions.headers || {}, headers, extraHeaders || {});
        const requestInit = {
            ...otherOptions,
            method: 'POST',
            body: JSON.stringify({
                ...params,
                ...extraParams || {}
            }),
            params: {
                ...params,
                ...extraParams
            },
            headers: margeHeaders,
            signal: this.abortController.signal,
            middlewares
        };
        if (timeout && timeout > 0) {
            this.timeoutHandler = window.setTimeout(()=>{
                this.isTimeout = true;
                this.finishRequest();
                callbacks?.onError?.(new Error('TimeoutError'));
            }, timeout);
        }
        this.startRequest();
        // save and export a async handler to wait for the request to be finished
        // though it is not necessary, but it is useful for some scenarios
        this._asyncHandler = __TURBOPACK__default__export__5(this.baseURL, {
            fetch,
            ...requestInit
        }).then(async (response)=>{
            clearTimeout(this.timeoutHandler);
            if (this.isTimeout) return;
            if (transformStream) {
                let transformer = transformStream;
                if (typeof transformStream === 'function') {
                    transformer = transformStream(this.baseURL, response.headers);
                }
                await this.customResponseHandler(response, callbacks, transformer, streamTimeout, streamSeparator, partSeparator, kvSeparator);
                return;
            }
            const contentType = response.headers.get('content-type') || '';
            const mimeType = contentType.split(';')[0].trim();
            switch(mimeType){
                /** SSE */ case 'text/event-stream':
                    await this.sseResponseHandler(response, callbacks, streamTimeout, streamSeparator, partSeparator, kvSeparator);
                    break;
                /** JSON */ case 'application/json':
                    await this.jsonResponseHandler(response, callbacks);
                    break;
                default:
                    throw new Error(`The response content-type: ${contentType} is not support!`);
            }
        }).catch((error)=>{
            clearTimeout(this.timeoutHandler);
            this.finishRequest();
            // abort() throw a DOMException, so we need to check it
            const err = error instanceof Error || error instanceof DOMException ? error : new Error('Unknown error!');
            // get retry interval from return of onError or options
            const returnOfOnError = callbacks?.onError?.(err);
            // ignore abort error
            if (err.name !== 'AbortError') {
                const retryInterval = typeof returnOfOnError === 'number' ? returnOfOnError : this.options.retryInterval;
                if (retryInterval && retryInterval > 0) {
                    // if retry times limit is set, check if the retry times is reached
                    if (typeof this.options.retryTimes === 'number' && this.retryTimes >= this.options.retryTimes) {
                        return;
                    }
                    clearTimeout(this.retryTimer);
                    this.retryTimer = setTimeout(()=>{
                        const extraHeaders = {};
                        if (typeof this.lastEventId !== 'undefined') {
                            // add Last-Event-ID header for retry
                            extraHeaders[LastEventId] = this.lastEventId;
                        }
                        this.init(this.lastManualParams, extraHeaders);
                    }, retryInterval);
                    this.retryTimes = this.retryTimes + 1;
                }
            }
        });
    }
    startRequest() {
        this._isRequesting = true;
    }
    finishRequest() {
        this._isRequesting = false;
    }
    customResponseHandler = async (response, callbacks, transformStream, streamTimeout, streamSeparator, partSeparator, kvSeparator)=>{
        const stream = __TURBOPACK__default__export__4({
            readableStream: response.body,
            transformStream,
            streamSeparator,
            partSeparator,
            kvSeparator
        });
        await this.processStream(stream, response, callbacks, streamTimeout);
    };
    sseResponseHandler = async (response, callbacks, streamTimeout, streamSeparator, partSeparator, kvSeparator)=>{
        const stream = __TURBOPACK__default__export__4({
            readableStream: response.body,
            streamSeparator,
            partSeparator,
            kvSeparator
        });
        await this.processStream(stream, response, callbacks, streamTimeout);
    };
    async processStream(stream, response, callbacks, streamTimeout) {
        const chunks = [];
        const iterator = stream[Symbol.asyncIterator]();
        let result;
        do {
            // if streamTimeout is set, start the stream timeout timer
            // every time the stream is updated, reset the timer
            if (streamTimeout) {
                this.streamTimeoutHandler = window.setTimeout(()=>{
                    this.isStreamTimeout = true;
                    this.finishRequest();
                    callbacks?.onError?.(new Error('StreamTimeoutError'), undefined, response.headers);
                }, streamTimeout);
            }
            result = await iterator.next();
            clearTimeout(this.streamTimeoutHandler);
            if (this.isStreamTimeout) {
                break;
            }
            if (result.value) {
                chunks.push(result.value);
                callbacks?.onUpdate?.(result.value, response.headers);
                if (typeof result?.value?.id !== 'undefined') {
                    // cache Last-Event-ID for retry request
                    this.lastEventId = result.value.id;
                }
            }
        }while (!result.done)
        if (streamTimeout) {
            clearTimeout(this.streamTimeoutHandler);
            if (this.isStreamTimeout) {
                this.finishRequest();
                return;
            }
        }
        this.finishRequest();
        callbacks?.onSuccess?.(chunks, response.headers);
    }
    jsonResponseHandler = async (response, callbacks)=>{
        const chunk = await response.json();
        if (chunk?.success === false) {
            const error = new Error(chunk.message || 'System error');
            error.name = chunk.name || 'SystemError';
            callbacks?.onError?.(error, chunk, response.headers);
        } else {
            callbacks?.onUpdate?.(chunk, response.headers);
            this.finishRequest();
            // keep type consistency with stream mode
            callbacks?.onSuccess?.([
                chunk
            ], response.headers);
        }
    };
    resetRetry() {
        clearTimeout(this.retryTimer);
        this.retryTimes = 0;
        this.lastEventId = undefined;
    }
}
function XRequest(baseURL, options) {
    return new XRequestClass(baseURL, options);
}
var __TURBOPACK__default__export__6 = XRequest;
__turbopack_context__.s([
    "AbstractChatProvider",
    ()=>AbstractChatProvider,
    "AbstractXRequestClass",
    ()=>AbstractXRequestClass,
    "DeepSeekChatProvider",
    ()=>DeepSeekChatProvider,
    "DefaultChatProvider",
    ()=>DefaultChatProvider,
    "OpenAIChatProvider",
    ()=>OpenAIChatProvider,
    "XRequest",
    0,
    __TURBOPACK__default__export__6,
    "XStream",
    0,
    __TURBOPACK__default__export__4,
    "useXChat",
    ()=>useXChat,
    "useXConversations",
    ()=>useXConversations
], 643);
}),
},
{"otherChunks":[],"runtimeModuleIds":[643]},
]]);


//# sourceMappingURL=x-sdk.js.map