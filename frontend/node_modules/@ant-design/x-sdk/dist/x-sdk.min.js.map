{"version":3,"sources":["turbopack:///[@utoo/pack-runtime]/umd/runtime-utils.ts","turbopack:///[@utoo/pack-runtime]/umd/runtime-base.ts","turbopack:///[@utoo/pack-runtime]/umd/build-base.ts","turbopack:///[@utoo/pack-runtime]/umd/base-externals-utils.ts","turbopack:///[@utoo/pack-runtime]/umd/runtime-backend-dom.ts","turbopack:///[project]/node_modules/react-is/cjs/react-is.production.min.js","turbopack:///[project]/node_modules/react-is/index.js","turbopack:///[project]/packages/x-sdk/src/chat-providers/AbstractChatProvider.ts","turbopack:///[project]/packages/x-sdk/src/chat-providers/DeepSeekChatProvider.ts","turbopack:///[project]/packages/x-sdk/src/chat-providers/DefaultChatProvider.ts","turbopack:///[project]/packages/x-sdk/src/chat-providers/OpenAIChatProvider.ts","turbopack:///[project]/node_modules/@rc-component/util/es/hooks/useEvent.js","turbopack:///[project]/node_modules/@rc-component/util/es/Dom/canUseDom.js","turbopack:///[project]/node_modules/@rc-component/util/es/hooks/useLayoutEffect.js","turbopack:///[project]/node_modules/@rc-component/util/es/hooks/useState.js","turbopack:///[project]/node_modules/@rc-component/util/es/hooks/useMergedState.js","turbopack:///[project]/node_modules/@rc-component/util/es/hooks/useControlledState.js","turbopack:///[project]/node_modules/@rc-component/util/es/ref.js","turbopack:///[project]/node_modules/@rc-component/util/es/hooks/useMemo.js","turbopack:///[project]/node_modules/@rc-component/util/es/React/isFragment.js","turbopack:///[project]/node_modules/@rc-component/util/es/utils/get.js","turbopack:///[project]/node_modules/@rc-component/util/es/utils/set.js","turbopack:///[project]/node_modules/@rc-component/util/es/warning.js","turbopack:///[project]/node_modules/@rc-component/util/es/omit.js","turbopack:///[project]/node_modules/@rc-component/util/es/Children/toArray.js","turbopack:///[project]/packages/x-sdk/src/x-chat/store.ts","turbopack:///[project]/packages/x-sdk/src/x-chat/index.ts","turbopack:///[project]/packages/x-sdk/src/x-conversations/store.ts","turbopack:///[project]/packages/x-sdk/src/x-conversations/index.ts","turbopack:///[project]/packages/x-sdk/src/x-stream/index.ts","turbopack:///[project]/packages/x-sdk/src/x-request/x-fetch.ts","turbopack:///[project]/packages/x-sdk/src/x-request/index.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype EsmNamespaceObject = Record<string, any>;\n\n// @ts-ignore Defined in `dev-base.ts`\ndeclare function getOrInstantiateModuleFromParent<M extends Module>(\n  id: M[\"id\"],\n  sourceModule: M,\n): M;\n\nconst REEXPORTED_OBJECTS = Symbol(\"reexported objects\");\n\n/**\n * Constructs the `__turbopack_context__` object for a module.\n */\nfunction Context(this: TurbopackBaseContext<Module>, module: Module) {\n  this.m = module;\n  this.e = module.exports;\n}\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>;\n\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>;\n\ninterface ModuleContextEntry {\n  id: () => ModuleId;\n  module: () => any;\n}\n\ninterface ModuleContext {\n  // require call\n  (moduleId: ModuleId): Exports | EsmNamespaceObject;\n\n  // async import call\n  import(moduleId: ModuleId): Promise<Exports | EsmNamespaceObject>;\n\n  keys(): ModuleId[];\n\n  resolve(moduleId: ModuleId): ModuleId;\n}\n\ntype GetOrInstantiateModuleFromParent<M> = (\n  moduleId: ModuleId,\n  parentModule: M,\n) => M;\n\ndeclare function getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId,\n): Module;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst toStringTag = typeof Symbol !== \"undefined\" && Symbol.toStringTag;\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>,\n) {\n  if (!hasOwnProperty.call(obj, name))\n    Object.defineProperty(obj, name, options);\n}\n\nfunction getOverwrittenModule(\n  moduleCache: ModuleCache<Module>,\n  id: ModuleId,\n): Module {\n  let module = moduleCache[id];\n  if (!module) {\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\n    // instantiateModule and the cache entry wasn't created yet.\n    module = createModuleObject(id);\n    moduleCache[id] = module;\n  }\n  return module;\n}\n\n/**\n * Creates the module object. Only done here to ensure all module objects have the same shape.\n */\nfunction createModuleObject(id: ModuleId): Module {\n  return {\n    exports: {},\n    error: undefined,\n    loaded: false,\n    id,\n    namespaceObject: undefined,\n    [REEXPORTED_OBJECTS]: undefined,\n  };\n}\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(\n  exports: Exports,\n  getters: Record<string, (() => any) | [() => any, (v: any) => void]>,\n) {\n  defineProp(exports, \"__esModule\", { value: true });\n  if (toStringTag) defineProp(exports, toStringTag, { value: \"Module\" });\n  for (const key in getters) {\n    const item = getters[key];\n    if (Array.isArray(item)) {\n      defineProp(exports, key, {\n        get: item[0],\n        set: item[1],\n        enumerable: true,\n      });\n    } else {\n      defineProp(exports, key, { get: item, enumerable: true });\n    }\n  }\n  Object.seal(exports);\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  this: TurbopackBaseContext<Module>,\n  getters: Record<string, () => any>,\n  id: ModuleId | undefined,\n) {\n  let module = this.m;\n  let exports = this.e;\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id);\n    exports = module.exports;\n  }\n  module.namespaceObject = module.exports;\n  esm(exports, getters);\n}\ncontextPrototype.s = esmExport;\n\nfunction ensureDynamicExports(module: Module, exports: Exports) {\n  let reexportedObjects = module[REEXPORTED_OBJECTS];\n\n  if (!reexportedObjects) {\n    reexportedObjects = module[REEXPORTED_OBJECTS] = [];\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === \"default\" ||\n          prop === \"__esModule\"\n        ) {\n          return Reflect.get(target, prop);\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop);\n          if (value !== undefined) return value;\n        }\n        return undefined;\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target);\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== \"default\" && !keys.includes(key)) keys.push(key);\n          }\n        }\n        return keys;\n      },\n    });\n  }\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  this: TurbopackBaseContext<Module>,\n  object: Record<string, any>,\n  id: ModuleId | undefined,\n) {\n  let module = this.m;\n  let exports = this.e;\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id);\n    exports = module.exports;\n  }\n  ensureDynamicExports(module, exports);\n\n  if (typeof object === \"object\" && object !== null) {\n    module[REEXPORTED_OBJECTS]!.push(object);\n  }\n}\ncontextPrototype.j = dynamicExport;\n\nfunction exportValue(\n  this: TurbopackBaseContext<Module>,\n  value: any,\n  id: ModuleId | undefined,\n) {\n  let module = this.m;\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id);\n  }\n  module.exports = value;\n}\ncontextPrototype.v = exportValue;\n\nfunction exportNamespace(\n  this: TurbopackBaseContext<Module>,\n  namespace: any,\n  id: ModuleId | undefined,\n) {\n  let module = this.m;\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id);\n  }\n  module.exports = module.namespaceObject = namespace;\n}\ncontextPrototype.n = exportNamespace;\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key];\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__;\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)];\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean,\n) {\n  const getters: { [s: string]: () => any } = Object.create(null);\n  for (\n    let current = raw;\n    (typeof current === \"object\" || typeof current === \"function\") &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      getters[key] = createGetter(raw, key);\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && \"default\" in getters)) {\n    getters[\"default\"] = () => raw;\n  }\n\n  esm(ns, getters);\n  return ns;\n}\n\nfunction createNS(raw: Module[\"exports\"]): EsmNamespaceObject {\n  if (typeof raw === \"function\") {\n    return function (this: any, ...args: any[]) {\n      return raw.apply(this, args);\n    };\n  } else {\n    return Object.create(null);\n  }\n}\n\nfunction esmImport(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId,\n): Exclude<Module[\"namespaceObject\"], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, this.m);\n  if (module.error) throw module.error;\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject;\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports;\n  return (module.namespaceObject = interopEsm(\n    raw,\n    createNS(raw),\n    raw && (raw as any).__esModule,\n  ));\n}\ncontextPrototype.i = esmImport;\n\nfunction asyncLoader(\n  this: TurbopackBaseContext<Module>,\n  moduleId: ModuleId,\n): Promise<Exports> {\n  const loader = this.r(moduleId) as (\n    importFunction: EsmImport,\n  ) => Promise<Exports>;\n  return loader(this.i.bind(this));\n}\ncontextPrototype.A = asyncLoader;\n\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire =\n  // @ts-ignore\n  typeof require === \"function\"\n    ? // @ts-ignore\n      require\n    : function require() {\n        throw new Error(\"Unexpected use of runtime require\");\n      };\ncontextPrototype.t = runtimeRequire;\n\nfunction commonJsRequire(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId,\n): Exports {\n  const module = getOrInstantiateModuleFromParent(id, this.m);\n  if (module.error) throw module.error;\n  return module.exports;\n}\ncontextPrototype.r = commonJsRequire;\n\n/**\n * `require.context` and require/import expression runtime.\n */\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\n  function moduleContext(id: ModuleId): Exports {\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].module();\n    }\n\n    const e = new Error(`Cannot find module '${id}'`);\n    (e as any).code = \"MODULE_NOT_FOUND\";\n    throw e;\n  }\n\n  moduleContext.keys = (): ModuleId[] => {\n    return Object.keys(map);\n  };\n\n  moduleContext.resolve = (id: ModuleId): ModuleId => {\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].id();\n    }\n\n    const e = new Error(`Cannot find module '${id}'`);\n    (e as any).code = \"MODULE_NOT_FOUND\";\n    throw e;\n  };\n\n  moduleContext.import = async (id: ModuleId) => {\n    return await (moduleContext(id) as Promise<Exports>);\n  };\n\n  return moduleContext;\n}\ncontextPrototype.f = moduleContext;\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === \"string\" ? chunkData : chunkData.path;\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === \"object\" &&\n    \"then\" in maybePromise &&\n    typeof maybePromise.then === \"function\"\n  );\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj;\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void;\n  let reject: (reason?: any) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej;\n    resolve = res;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol(\"turbopack queues\");\nconst turbopackExports = Symbol(\"turbopack exports\");\nconst turbopackError = Symbol(\"turbopack error\");\n\nconst enum QueueStatus {\n  Unknown = -1,\n  Unresolved = 0,\n  Resolved = 1,\n}\n\ntype AsyncQueueFn = (() => void) & { queueCount: number };\ntype AsyncQueue = AsyncQueueFn[] & {\n  status: QueueStatus;\n};\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && queue.status !== QueueStatus.Resolved) {\n    queue.status = QueueStatus.Resolved;\n    queue.forEach((fn) => fn.queueCount--);\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()));\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>;\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void;\n  [turbopackExports]: Exports;\n  [turbopackError]?: any;\n};\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt;\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep): AsyncModuleExt => {\n    if (dep !== null && typeof dep === \"object\") {\n      if (isAsyncModuleExt(dep)) return dep;\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], {\n          status: QueueStatus.Unresolved,\n        });\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        };\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res;\n            resolveQueue(queue);\n          },\n          (err) => {\n            obj[turbopackError] = err;\n            resolveQueue(queue);\n          },\n        );\n\n        return obj;\n      }\n    }\n\n    return {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    };\n  });\n}\n\nfunction asyncModule(\n  this: TurbopackBaseContext<Module>,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[],\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void,\n  ) => void,\n  hasAwait: boolean,\n) {\n  const module = this.m;\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { status: QueueStatus.Unknown })\n    : undefined;\n\n  const depQueues: Set<AsyncQueue> = new Set();\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>();\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: module.exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue);\n      depQueues.forEach(fn);\n      promise[\"catch\"](() => {});\n    },\n  } satisfies AsyncModuleExt);\n\n  const attributes: PropertyDescriptor = {\n    get(): any {\n      return promise;\n    },\n    set(v: any) {\n      // Calling `esmExport` leads to this.\n      if (v !== promise) {\n        promise[turbopackExports] = v;\n      }\n    },\n  };\n\n  Object.defineProperty(module, \"exports\", attributes);\n  Object.defineProperty(module, \"namespaceObject\", attributes);\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps);\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError];\n        return d[turbopackExports];\n      });\n\n    const { promise, resolve } = createPromise<() => Exports[]>();\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    });\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q);\n        if (q && q.status === QueueStatus.Unresolved) {\n          fn.queueCount++;\n          q.push(fn);\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue));\n\n    return fn.queueCount ? promise : getResult();\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err));\n    } else {\n      resolve(promise[turbopackExports]);\n    }\n\n    resolveQueue(queue);\n  }\n\n  body(handleAsyncDependencies, asyncResult);\n\n  if (queue && queue.status === QueueStatus.Unknown) {\n    queue.status = QueueStatus.Unresolved;\n  }\n}\ncontextPrototype.a = asyncModule;\n\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\n  const realUrl = new URL(inputUrl, \"x:/\");\n  const values: Record<string, any> = {};\n  for (const key in realUrl) values[key] = (realUrl as any)[key];\n  values.href = inputUrl;\n  values.pathname = inputUrl.replace(/[?#].*/, \"\");\n  values.origin = values.protocol = \"\";\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl;\n  for (const key in values)\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      configurable: true,\n      value: values[key],\n    });\n};\n\nrelativeURL.prototype = URL.prototype;\ncontextPrototype.U = relativeURL;\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`);\n}\n\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */\nfunction requireStub(_moduleId: ModuleId): never {\n  throw new Error(\"dynamic usage of require is not supported\");\n}\ncontextPrototype.z = requireStub;\n\ntype ContextConstructor<M> = {\n  new (module: Module): TurbopackBaseContext<M>;\n};\n","/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./globals.d.ts\" />\n/// <reference path=\"./runtime-utils.ts\" />\n\n// Used in WebWorkers to tell the runtime about the chunk base path\ndeclare var TURBOPACK_WORKER_LOCATION: string;\n// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript\n// Note it's stored in reversed order to use push and pop\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined;\n\n// Injected by rust code\ndeclare var CHUNK_BASE_PATH: string;\ndeclare var CHUNK_SUFFIX_PATH: string;\n\ninterface TurbopackBrowserBaseContext<M> extends TurbopackBaseContext<M> {\n  R: ResolvePathFromModule;\n}\n\nconst browserContextPrototype =\n  Context.prototype as TurbopackBrowserBaseContext<unknown>;\n\n// Provided by build\ndeclare function instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData,\n): Module;\n\ntype RuntimeParams = {\n  otherChunks: ChunkData[];\n  runtimeModuleIds: ModuleId[];\n};\n\ntype ChunkRegistration = [\n  chunkPath: ChunkScript,\n  chunkModules: CompressedModuleFactories,\n  params: RuntimeParams | undefined,\n];\n\ntype ChunkList = {\n  script: ChunkListScript;\n  chunks: ChunkData[];\n  source: \"entry\" | \"dynamic\";\n};\n\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   * SourceData is a ChunkPath.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   * SourceData is a ModuleId.\n   */\n  Parent = 1,\n  /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   * SourceData is an array of ModuleIds or undefined.\n   */\n  Update = 2,\n}\n\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined;\ninterface RuntimeBackend {\n  registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void;\n  /**\n   * Returns the same Promise for the same chunk URL.\n   */\n  loadChunkCached: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    chunkUrl: ChunkUrl,\n  ) => Promise<void>;\n}\n\nconst moduleFactories: ModuleFactories = Object.create(null);\ncontextPrototype.M = moduleFactories;\n\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map();\n\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map();\n\nfunction factoryNotAvailable(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData,\n) {\n  let instantiationReason;\n  switch (sourceType) {\n    case SourceType.Runtime:\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`;\n      break;\n    case SourceType.Parent:\n      instantiationReason = `because it was required from module ${sourceData}`;\n      break;\n    case SourceType.Update:\n      instantiationReason = \"because of an HMR update\";\n      break;\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`,\n      );\n  }\n  throw new Error(\n    `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`,\n  );\n}\n\nconst loadedChunk = Promise.resolve(undefined);\nconst instrumentedBackendLoadChunks = new WeakMap<\n  Promise<any>,\n  Promise<any> | typeof loadedChunk\n>();\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrl(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkUrl: ChunkUrl,\n) {\n  return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl);\n}\nbrowserContextPrototype.L = loadChunkByUrl;\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrlInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkUrl: ChunkUrl,\n): Promise<any> {\n  const thenable = BACKEND.loadChunkCached(sourceType, sourceData, chunkUrl);\n  let entry = instrumentedBackendLoadChunks.get(thenable);\n  if (entry === undefined) {\n    const resolve = instrumentedBackendLoadChunks.set.bind(\n      instrumentedBackendLoadChunks,\n      thenable,\n      loadedChunk,\n    );\n    entry = thenable.then(resolve).catch((error) => {\n      let loadReason;\n      switch (sourceType) {\n        case SourceType.Runtime:\n          loadReason = `as a runtime dependency of chunk ${sourceData}`;\n          break;\n        case SourceType.Parent:\n          loadReason = `from module ${sourceData}`;\n          break;\n        case SourceType.Update:\n          loadReason = \"from an HMR update\";\n          break;\n        default:\n          invariant(\n            sourceType,\n            (sourceType) => `Unknown source type: ${sourceType}`,\n          );\n      }\n      throw new Error(\n        `Failed to load chunk ${chunkUrl} ${loadReason}${\n          error ? `: ${error}` : \"\"\n        }`,\n        error\n          ? {\n              cause: error,\n            }\n          : undefined,\n      );\n    });\n    instrumentedBackendLoadChunks.set(thenable, entry);\n  }\n\n  return entry;\n}\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkPath(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkPath: ChunkPath,\n): Promise<void> {\n  const url = getChunkRelativeUrl(chunkPath);\n  return loadChunkByUrlInternal(sourceType, sourceData, url);\n}\n\n/**\n * Returns an absolute url to an asset.\n */\nfunction resolvePathFromModule(\n  this: TurbopackBaseContext<Module>,\n  moduleId: string,\n): string {\n  const exported = this.r(moduleId);\n  return exported?.default ?? exported;\n}\nbrowserContextPrototype.R = resolvePathFromModule;\n\n/**\n * no-op for browser\n * @param modulePath\n */\nfunction resolveAbsolutePath(modulePath?: string): string {\n  return `/ROOT/${modulePath ?? \"\"}`;\n}\nbrowserContextPrototype.P = resolveAbsolutePath;\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath,\n): Module {\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath);\n}\n/**\n * Returns the URL relative to the origin where a chunk can be fetched from.\n */\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\n  return `${CHUNK_BASE_PATH}${chunkPath\n    .split(\"/\")\n    .map((p) => encodeURIComponent(p))\n    .join(\"/\")}${CHUNK_SUFFIX_PATH}` as ChunkUrl;\n}\n\n/**\n * Return the ChunkPath from a ChunkScript.\n */\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath;\nfunction getPathFromScript(\n  chunkScript: ChunkListPath | ChunkListScript,\n): ChunkListPath;\nfunction getPathFromScript(\n  chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript,\n): ChunkPath | ChunkListPath {\n  if (typeof chunkScript === \"string\") {\n    return chunkScript as ChunkPath | ChunkListPath;\n  }\n  const chunkUrl =\n    typeof TURBOPACK_NEXT_CHUNK_URLS !== \"undefined\"\n      ? TURBOPACK_NEXT_CHUNK_URLS.pop()!\n      : chunkScript.getAttribute(\"src\")!;\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, \"\"));\n  let path = src.startsWith(CHUNK_BASE_PATH)\n    ? src.slice(CHUNK_BASE_PATH.length)\n    : src;\n  if (path.startsWith(\"/\")) {\n    path = path.slice(1);\n  }\n  return path as ChunkPath | ChunkListPath;\n}\n\nfunction registerCompressedModuleFactory(\n  moduleId: ModuleId,\n  moduleFactory: Function | [Function, ModuleId[]],\n) {\n  if (!moduleFactories[moduleId]) {\n    if (Array.isArray(moduleFactory)) {\n      let [moduleFactoryFn, otherIds] = moduleFactory;\n      moduleFactories[moduleId] = moduleFactoryFn;\n      for (const otherModuleId of otherIds) {\n        moduleFactories[otherModuleId] = moduleFactoryFn;\n      }\n    } else {\n      moduleFactories[moduleId] = moduleFactory;\n    }\n  }\n}\n\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n  return regexJsUrl.test(chunkUrlOrPath);\n}\n","/// <reference path=\"./runtime-base.ts\" />\n/// <reference path=\"./dummy.ts\" />\n\nconst moduleCache: ModuleCache<Module> = {};\ncontextPrototype.c = moduleCache;\n\n/**\n * Gets or instantiates a runtime module.\n */\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId,\n): Module {\n  const module = moduleCache[moduleId];\n  if (module) {\n    if (module.error) {\n      throw module.error;\n    }\n    return module;\n  }\n\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath);\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\n// Used by the backend\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\n  Module\n> = (id, sourceModule) => {\n  const module = moduleCache[id];\n\n  if (module) {\n    return module;\n  }\n\n  return instantiateModule(id, SourceType.Parent, sourceModule.id);\n};\n\nfunction instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData,\n): Module {\n  const moduleFactory = moduleFactories[id];\n  if (typeof moduleFactory !== \"function\") {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    factoryNotAvailable(id, sourceType, sourceData);\n  }\n\n  const module: Module = createModuleObject(id);\n\n  moduleCache[id] = module;\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  try {\n    const context = new (Context as any as ContextConstructor<Module>)(module);\n    moduleFactory(context);\n  } catch (error) {\n    module.error = error as any;\n    throw error;\n  }\n\n  module.loaded = true;\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject);\n  }\n\n  return module;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction registerChunk([\n  chunkScript,\n  chunkModules,\n  runtimeParams,\n]: ChunkRegistration) {\n  const chunkPath = getPathFromScript(chunkScript);\n  for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n    registerCompressedModuleFactory(moduleId, moduleFactory);\n  }\n\n  return BACKEND.registerChunk(chunkPath, runtimeParams);\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-utils.ts\" />\n\n/// A 'base' utilities to support runtime can have externals.\n/// Currently this is for node.js / edge runtime both.\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\n\nasync function externalImport(id: DependencySpecifier) {\n  let raw;\n  try {\n    raw = await import(id);\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`);\n  }\n\n  if (raw && raw.__esModule && raw.default && \"default\" in raw.default) {\n    return interopEsm(raw.default, createNS(raw), true);\n  }\n\n  return raw;\n}\ncontextPrototype.y = externalImport;\n\nfunction externalRequire(\n  id: ModuleId,\n  thunk: () => any,\n  esm: boolean = false,\n): Exports | EsmNamespaceObject {\n  let raw;\n  try {\n    raw = thunk();\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`);\n  }\n\n  if (!esm || raw.__esModule) {\n    return raw;\n  }\n\n  return interopEsm(raw, createNS(raw), true);\n}\n\nexternalRequire.resolve = (\n  id: string,\n  options?: {\n    paths?: string[];\n  },\n) => {\n  return require.resolve(id, options);\n};\ncontextPrototype.x = externalRequire;\n","/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript DOM runtime.\n *\n * It will be appended to the base development runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-base.ts\" />\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype ChunkResolver = {\n  resolved: boolean;\n  loadingStarted: boolean;\n  resolve: () => void;\n  reject: (error?: Error) => void;\n  promise: Promise<any>;\n};\n\nlet BACKEND: RuntimeBackend;\n\n/**\n * Maps chunk paths to the corresponding resolver.\n */\nconst chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map();\n\n(() => {\n  BACKEND = {\n    registerChunk(chunkPath, params) {\n      const chunkUrl = getChunkRelativeUrl(chunkPath);\n\n      const resolver = getOrCreateResolver(chunkUrl);\n      resolver.resolve();\n\n      if (params == null) {\n        return;\n      }\n\n      for (const otherChunkData of params.otherChunks) {\n        const otherChunkPath = getChunkPath(otherChunkData);\n        const otherChunkUrl = getChunkRelativeUrl(otherChunkPath);\n\n        // Chunk might have started loading, so we want to avoid triggering another load.\n        getOrCreateResolver(otherChunkUrl);\n      }\n\n      if (params.runtimeModuleIds.length > 0) {\n        for (const moduleId of params.runtimeModuleIds) {\n          getOrInstantiateRuntimeModule(chunkPath, moduleId);\n        }\n      }\n    },\n\n    /**\n     * Loads the given chunk, and returns a promise that resolves once the chunk\n     * has been loaded.\n     */\n    loadChunkCached(\n      sourceType: SourceType,\n      sourceData: SourceData,\n      chunkUrl: ChunkUrl,\n    ) {\n      return doLoadChunk(sourceType, sourceData, chunkUrl);\n    },\n  };\n  function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {\n    let resolver = chunkResolvers.get(chunkUrl);\n    if (!resolver) {\n      let resolve: () => void;\n      let reject: (error?: Error) => void;\n      const promise = new Promise<void>((innerResolve, innerReject) => {\n        resolve = innerResolve;\n        reject = innerReject;\n      });\n      resolver = {\n        resolved: false,\n        loadingStarted: false,\n        promise,\n        resolve: () => {\n          resolver!.resolved = true;\n          resolve();\n        },\n        reject: reject!,\n      };\n      chunkResolvers.set(chunkUrl, resolver);\n    }\n    return resolver;\n  }\n\n  /**\n   * Loads the given chunk, and returns a promise that resolves once the chunk\n   * has been loaded.\n   */\n  function doLoadChunk(\n    sourceType: SourceType,\n    _sourceData: SourceData,\n    chunkUrl: ChunkUrl,\n  ) {\n    const resolver = getOrCreateResolver(chunkUrl);\n    if (resolver.loadingStarted) {\n      return resolver.promise;\n    }\n\n    if (sourceType === SourceType.Runtime) {\n      // We don't need to load chunks references from runtime code, as they're already\n      // present in the DOM.\n      resolver.loadingStarted = true;\n\n      // We need to wait for JS chunks to register themselves within `registerChunk`\n      // before we can start instantiating runtime modules, hence the absence of\n      // `resolver.resolve()` in this branch.\n\n      return resolver.promise;\n    }\n\n    if (typeof importScripts === \"function\") {\n      // We're in a web worker\n      if (isJs(chunkUrl)) {\n        self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl);\n        importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n      } else {\n        throw new Error(\n          `can't infer type of chunk from URL ${chunkUrl} in worker`,\n        );\n      }\n    } else {\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n      const decodedChunkUrl = decodeURI(chunkUrl);\n\n      if (isJs(chunkUrl)) {\n        const previousScripts = document.querySelectorAll(\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`,\n        );\n        if (previousScripts.length > 0) {\n          // There is this edge where the script already failed loading, but we\n          // can't detect that. The Promise will never resolve in this case.\n          for (const script of Array.from(previousScripts)) {\n            script.addEventListener(\"error\", () => {\n              resolver.reject();\n            });\n          }\n        } else {\n          const script = document.createElement(\"script\");\n          script.src = chunkUrl;\n          // We'll only mark the chunk as loaded once the script has been executed,\n          // which happens in `registerChunk`. Hence the absence of `resolve()` in\n          // this branch.\n          script.onerror = () => {\n            resolver.reject();\n          };\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(script);\n        }\n      } else {\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n      }\n    }\n\n    resolver.loadingStarted = true;\n    return resolver.promise;\n  }\n})();\n","/**\n * @license React\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var b=Symbol.for(\"react.element\"),c=Symbol.for(\"react.portal\"),d=Symbol.for(\"react.fragment\"),e=Symbol.for(\"react.strict_mode\"),f=Symbol.for(\"react.profiler\"),g=Symbol.for(\"react.provider\"),h=Symbol.for(\"react.context\"),k=Symbol.for(\"react.server_context\"),l=Symbol.for(\"react.forward_ref\"),m=Symbol.for(\"react.suspense\"),n=Symbol.for(\"react.suspense_list\"),p=Symbol.for(\"react.memo\"),q=Symbol.for(\"react.lazy\"),t=Symbol.for(\"react.offscreen\"),u;u=Symbol.for(\"react.module.reference\");\nfunction v(a){if(\"object\"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}exports.ContextConsumer=h;exports.ContextProvider=g;exports.Element=b;exports.ForwardRef=l;exports.Fragment=d;exports.Lazy=q;exports.Memo=p;exports.Portal=c;exports.Profiler=f;exports.StrictMode=e;exports.Suspense=m;\nexports.SuspenseList=n;exports.isAsyncMode=function(){return!1};exports.isConcurrentMode=function(){return!1};exports.isContextConsumer=function(a){return v(a)===h};exports.isContextProvider=function(a){return v(a)===g};exports.isElement=function(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===b};exports.isForwardRef=function(a){return v(a)===l};exports.isFragment=function(a){return v(a)===d};exports.isLazy=function(a){return v(a)===q};exports.isMemo=function(a){return v(a)===p};\nexports.isPortal=function(a){return v(a)===c};exports.isProfiler=function(a){return v(a)===f};exports.isStrictMode=function(a){return v(a)===e};exports.isSuspense=function(a){return v(a)===m};exports.isSuspenseList=function(a){return v(a)===n};\nexports.isValidElementType=function(a){return\"string\"===typeof a||\"function\"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||\"object\"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};exports.typeOf=v;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n","import type { MessageStatus, SimpleType } from '../x-chat';\nimport type { AbstractXRequestClass, XRequestCallbacks, XRequestOptions } from '../x-request';\n\nexport interface ChatProviderConfig<Input, Output, ChatMessage extends SimpleType = any> {\n  request:\n    | AbstractXRequestClass<Input, Output, ChatMessage>\n    | (() => AbstractXRequestClass<Input, Output, ChatMessage>);\n}\n\nexport interface TransformMessage<ChatMessage extends SimpleType, Output> {\n  originMessage?: ChatMessage;\n  chunk: Output;\n  chunks: Output[];\n  status: MessageStatus;\n  responseHeaders: Headers;\n}\n\nexport default abstract class AbstractChatProvider<ChatMessage extends SimpleType, Input, Output> {\n  private _request!: AbstractXRequestClass<Input, Output, ChatMessage>;\n  private _getMessagesFn!: () => ChatMessage[];\n  private _originalCallbacks?: XRequestCallbacks<Output, ChatMessage>;\n\n  public get request() {\n    return this._request;\n  }\n\n  constructor(config: ChatProviderConfig<Input, Output, ChatMessage>) {\n    const request = typeof config.request === 'function' ? config.request() : config.request;\n    if (!request.manual) {\n      throw new Error('request must be manual');\n    }\n    this._request = request;\n    this._originalCallbacks = this._request.options?.callbacks;\n  }\n\n  /**\n   * 转换onRequest传入的参数，你可以和Provider实例化时request配置中的params进行合并或者额外处理\n   * @param requestParams 请求参数\n   * @param options 请求配置，从Provider实例化时request配置中来\n   */\n  abstract transformParams(\n    requestParams: Partial<Input>,\n    options: XRequestOptions<Input, Output, ChatMessage>,\n  ): Input;\n\n  /**\n   * 将onRequest传入的参数转换为本地（用户发送）的ChatMessage，用于消息渲染\n   * @param requestParams onRequest传入的参数\n   */\n  abstract transformLocalMessage(requestParams: Partial<Input>): ChatMessage | ChatMessage[];\n\n  /**\n   * 可在更新返回数据时对messages做转换，同时会更新到messages\n   * @param info\n   */\n  abstract transformMessage(info: TransformMessage<ChatMessage, Output>): ChatMessage;\n\n  getMessages(): ChatMessage[] {\n    return this?._getMessagesFn();\n  }\n\n  injectGetMessages(getMessages: () => ChatMessage[]) {\n    this._getMessagesFn = getMessages;\n  }\n\n  injectRequest({\n    onUpdate,\n    onSuccess,\n    onError,\n  }: {\n    onUpdate: (data: Output, responseHeaders: Headers) => any;\n    onSuccess: (data: Output[], responseHeaders: Headers) => any;\n    onError: (error: any, errorInfo?: any) => any;\n  }) {\n    const originalOnUpdate = this._originalCallbacks?.onUpdate;\n    const originalOnSuccess = this._originalCallbacks?.onSuccess;\n    const originalOnError = this._originalCallbacks?.onError;\n    this._request.options.callbacks = {\n      onUpdate: (data: Output, responseHeaders: Headers) => {\n        const msg = onUpdate(data, responseHeaders);\n        if (originalOnUpdate) originalOnUpdate(data, responseHeaders, msg);\n      },\n      onSuccess: (data: Output[], responseHeaders: Headers) => {\n        const msg = onSuccess(data, responseHeaders);\n        if (originalOnSuccess) originalOnSuccess(data, responseHeaders, msg);\n      },\n      onError: (error, errorInfo, responseHeaders) => {\n        const fallbackMsg = onError(error, errorInfo);\n        if (originalOnError) originalOnError(error, errorInfo, responseHeaders, fallbackMsg);\n      },\n    } as XRequestCallbacks<Output, any>;\n  }\n}\n","import { XRequestOptions } from '../x-request';\nimport { SSEFields } from '../x-stream';\nimport AbstractChatProvider, { TransformMessage } from './AbstractChatProvider';\nimport { XModelMessage, XModelParams } from './types/model';\n\n/**\n * DeepSeek Chat Provider\n * @template ChatMessage 消息类型\n * @template Input 请求参数类型\n * @template Output 响应数据类型\n */\nexport default class DeepSeekChatProvider<\n  ChatMessage extends XModelMessage = XModelMessage,\n  Input extends XModelParams = XModelParams,\n  Output extends Partial<Record<SSEFields, any>> = Partial<Record<SSEFields, any>>,\n> extends AbstractChatProvider<ChatMessage, Input, Output> {\n  transformParams(\n    requestParams: Partial<Input>,\n    options: XRequestOptions<Input, Output, ChatMessage>,\n  ): Input {\n    return {\n      ...(options?.params || {}),\n      ...requestParams,\n      messages: this.getMessages(),\n    } as unknown as Input;\n  }\n\n  transformLocalMessage(requestParams: Partial<Input>): ChatMessage[] {\n    return (requestParams?.messages || []) as ChatMessage[];\n  }\n\n  transformMessage(info: TransformMessage<ChatMessage, Output>): ChatMessage {\n    const { originMessage, chunk, responseHeaders } = info;\n    let currentContent = '';\n    let currentThink = '';\n    let role = 'assistant';\n    try {\n      let message: any;\n      if (responseHeaders.get('content-type')?.includes('text/event-stream')) {\n        if (chunk && chunk.data?.trim() !== '[DONE]') {\n          message = JSON.parse(chunk.data);\n        }\n      } else {\n        message = chunk;\n      }\n      if (message) {\n        message?.choices?.forEach((choice: any) => {\n          if (choice?.delta) {\n            currentThink = choice.delta.reasoning_content || '';\n            currentContent += choice.delta.content || '';\n            role = choice.delta.role;\n          } else if (choice?.message) {\n            currentThink = choice.message.reasoning_content || '';\n            currentContent += choice.message.content || '';\n            role = choice.message.role;\n          }\n        });\n      }\n    } catch (error) {\n      console.error('transformMessage error', error);\n    }\n    let content = '';\n    let originMessageContent =\n      typeof originMessage?.content === 'string'\n        ? originMessage?.content\n        : originMessage?.content.text || '';\n    if (!originMessageContent && currentThink) {\n      // 仅匹配最多前两个换行符，避免性能问题\n      content = `\\n\\n<think>\\n\\n${currentThink?.replace?.(/^\\n{0,2}/, '')}`;\n    } else if (\n      originMessageContent.includes('<think>') &&\n      !originMessageContent.includes('</think>') &&\n      currentContent\n    ) {\n      originMessageContent = originMessageContent.replace('<think>', '<think status=\"done\">');\n      // 仅匹配最多结尾的两个空白字符和换行符\n      content = `${originMessageContent?.replace?.(/[\\s\\n]{0,2}$/, '')}\\n\\n</think>\\n\\n${currentContent}`;\n    } else {\n      content = `${originMessageContent || ''}${currentThink}${currentContent}`;\n    }\n\n    return {\n      content,\n      role: role || 'assistant',\n    } as ChatMessage;\n  }\n}\n","import type { SimpleType } from '../x-chat';\nimport { XRequestOptions } from '../x-request';\nimport type { TransformMessage } from './AbstractChatProvider';\nimport AbstractChatProvider from './AbstractChatProvider';\nexport default class DefaultChatProvider<\n  ChatMessage extends SimpleType,\n  Input,\n  Output,\n> extends AbstractChatProvider<ChatMessage, Input, Output> {\n  transformParams(\n    requestParams: ChatMessage & Partial<Input>,\n    options: XRequestOptions<Input, Output, ChatMessage>,\n  ): Input {\n    if (typeof requestParams !== 'object') {\n      throw new Error('requestParams must be an object');\n    }\n    return {\n      ...(options?.params || {}),\n      ...(requestParams || {}),\n    } as unknown as Input;\n  }\n\n  transformLocalMessage(requestParams: Partial<Input>): ChatMessage {\n    return requestParams as unknown as ChatMessage;\n  }\n\n  transformMessage(info: TransformMessage<ChatMessage, Output>): ChatMessage {\n    const { chunk, chunks, originMessage } = info;\n\n    if (chunk) {\n      return chunk as unknown as ChatMessage;\n    }\n\n    if (Array.isArray(chunks)) {\n      const chunk = chunks?.length > 0 ? chunks?.[chunks?.length - 1] : undefined;\n      return originMessage ? originMessage : (chunk as unknown as ChatMessage);\n    }\n\n    return chunks as unknown as ChatMessage;\n  }\n}\n","import { XRequestOptions } from '../x-request';\nimport { SSEFields } from '../x-stream';\nimport type { TransformMessage } from './AbstractChatProvider';\nimport AbstractChatProvider from './AbstractChatProvider';\nimport { XModelMessage, XModelParams } from './types/model';\n/**\n * LLM OpenAI Compatible Chat Provider\n * @template ChatMessage 消息类型\n * @template Input 请求参数类型\n * @template Output 响应数据类型\n */\nexport default class OpenAIChatProvider<\n  ChatMessage extends XModelMessage = XModelMessage,\n  Input extends XModelParams = XModelParams,\n  Output extends Partial<Record<SSEFields, any>> = Partial<Record<SSEFields, any>>,\n> extends AbstractChatProvider<ChatMessage, Input, Output> {\n  transformParams(\n    requestParams: Partial<Input>,\n    options: XRequestOptions<Input, Output, ChatMessage>,\n  ): Input {\n    return {\n      ...(options?.params || {}),\n      ...requestParams,\n      messages: this.getMessages(),\n    } as unknown as Input;\n  }\n\n  transformLocalMessage(requestParams: Partial<Input>): ChatMessage[] {\n    return (requestParams?.messages || []) as ChatMessage[];\n  }\n\n  transformMessage(info: TransformMessage<ChatMessage, Output>): ChatMessage {\n    const { originMessage, chunk, responseHeaders } = info;\n    let currentContent = '';\n    let role = 'assistant';\n    try {\n      let message: any;\n      if (responseHeaders.get('content-type')?.includes('text/event-stream')) {\n        if (chunk && chunk.data?.trim() !== '[DONE]') {\n          message = JSON.parse(chunk.data);\n        }\n      } else {\n        message = chunk;\n      }\n      if (message) {\n        message?.choices?.forEach((choice: any) => {\n          if (choice?.delta) {\n            currentContent += choice.delta.content || '';\n            role = choice.delta.role || 'assistant';\n          } else if (choice?.message) {\n            currentContent += choice.message.content || '';\n            role = choice.message.role || 'assistant';\n          }\n        });\n      }\n    } catch (error) {\n      console.error('transformMessage error', error);\n    }\n\n    const content = `${originMessage?.content || ''}${currentContent || ''}`;\n\n    return {\n      content,\n      role,\n    } as ChatMessage;\n  }\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable react-hooks/exhaustive-deps */\nimport * as React from 'react';\nfunction useEvent(callback) {\n  const fnRef = React.useRef(callback);\n  fnRef.current = callback;\n  const memoFn = React.useCallback((...args) => fnRef.current?.(...args), []);\n  return memoFn;\n}\nexport default useEvent;","export default function canUseDom() {\n  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n}","import * as React from 'react';\nimport canUseDom from \"../Dom/canUseDom\";\n\n/**\n * Wrap `React.useLayoutEffect` which will not throw warning message in test env\n */\nconst useInternalLayoutEffect = process.env.NODE_ENV !== 'test' && canUseDom() ? React.useLayoutEffect : React.useEffect;\nconst useLayoutEffect = (callback, deps) => {\n  const firstMountRef = React.useRef(true);\n  useInternalLayoutEffect(() => {\n    return callback(firstMountRef.current);\n  }, deps);\n\n  // We tell react that first mount has passed\n  useInternalLayoutEffect(() => {\n    firstMountRef.current = false;\n    return () => {\n      firstMountRef.current = true;\n    };\n  }, []);\n};\nexport const useLayoutUpdateEffect = (callback, deps) => {\n  useLayoutEffect(firstMount => {\n    if (!firstMount) {\n      return callback();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n};\nexport default useLayoutEffect;","import * as React from 'react';\n/**\n * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.\n * We do not make this auto is to avoid real memory leak.\n * Developer should confirm it's safe to ignore themselves.\n */\nconst useSafeState = defaultValue => {\n  const destroyRef = React.useRef(false);\n  const [value, setValue] = React.useState(defaultValue);\n  React.useEffect(() => {\n    destroyRef.current = false;\n    return () => {\n      destroyRef.current = true;\n    };\n  }, []);\n  function safeSetState(updater, ignoreDestroy) {\n    if (ignoreDestroy && destroyRef.current) {\n      return;\n    }\n    setValue(updater);\n  }\n  return [value, safeSetState];\n};\nexport default useSafeState;","import useEvent from \"./useEvent\";\nimport { useLayoutUpdateEffect } from \"./useLayoutEffect\";\nimport useState from \"./useState\";\n/** We only think `undefined` is empty */\nfunction hasValue(value) {\n  return value !== undefined;\n}\n\n/**\n * @deprecated Please use `useControlledState` instead if not need support < React 18.\n * Similar to `useState` but will use props value if provided.\n * Note that internal use rc-util `useState` hook.\n */\nexport default function useMergedState(defaultStateValue, option) {\n  const {\n    defaultValue,\n    value,\n    onChange,\n    postState\n  } = option || {};\n\n  // ======================= Init =======================\n  const [innerValue, setInnerValue] = useState(() => {\n    if (hasValue(value)) {\n      return value;\n    } else if (hasValue(defaultValue)) {\n      return typeof defaultValue === 'function' ? defaultValue() : defaultValue;\n    } else {\n      return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;\n    }\n  });\n  const mergedValue = value !== undefined ? value : innerValue;\n  const postMergedValue = postState ? postState(mergedValue) : mergedValue;\n\n  // ====================== Change ======================\n  const onChangeFn = useEvent(onChange);\n  const [prevValue, setPrevValue] = useState([mergedValue]);\n  useLayoutUpdateEffect(() => {\n    const prev = prevValue[0];\n    if (innerValue !== prev) {\n      onChangeFn(innerValue, prev);\n    }\n  }, [prevValue]);\n\n  // Sync value back to `undefined` when it from control to un-control\n  useLayoutUpdateEffect(() => {\n    if (!hasValue(value)) {\n      setInnerValue(value);\n    }\n  }, [value]);\n\n  // ====================== Update ======================\n  const triggerChange = useEvent((updater, ignoreDestroy) => {\n    setInnerValue(updater, ignoreDestroy);\n    setPrevValue([mergedValue], ignoreDestroy);\n  });\n  return [postMergedValue, triggerChange];\n}","import { useState } from 'react';\nimport useLayoutEffect from \"./useLayoutEffect\";\n/**\n * Similar to `useState` but will use props value if provided.\n * From React 18, we do not need safe `useState` since it will not throw for unmounted update.\n * This hooks remove the `onChange` & `postState` logic since we only need basic merged state logic.\n */\nexport default function useControlledState(defaultStateValue, value) {\n  const [innerValue, setInnerValue] = useState(defaultStateValue);\n  const mergedValue = value !== undefined ? value : innerValue;\n  useLayoutEffect(mount => {\n    if (!mount) {\n      setInnerValue(value);\n    }\n  }, [value]);\n  return [\n  // Value\n  mergedValue,\n  // Update function\n  setInnerValue];\n}","import { isValidElement, version } from 'react';\nimport { ForwardRef, isMemo } from 'react-is';\nimport useMemo from \"./hooks/useMemo\";\nimport isFragment from \"./React/isFragment\";\nconst ReactMajorVersion = Number(version.split('.')[0]);\nexport const fillRef = (ref, node) => {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else if (typeof ref === 'object' && ref && 'current' in ref) {\n    ref.current = node;\n  }\n};\n\n/**\n * Merge refs into one ref function to support ref passing.\n */\nexport const composeRef = (...refs) => {\n  const refList = refs.filter(Boolean);\n  if (refList.length <= 1) {\n    return refList[0];\n  }\n  return node => {\n    refs.forEach(ref => {\n      fillRef(ref, node);\n    });\n  };\n};\nexport const useComposeRef = (...refs) => {\n  return useMemo(() => composeRef(...refs),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  refs, (prev, next) => prev.length !== next.length || prev.every((ref, i) => ref !== next[i]));\n};\nexport const supportRef = nodeOrComponent => {\n  if (!nodeOrComponent) {\n    return false;\n  }\n\n  // React 19 no need `forwardRef` anymore. So just pass if is a React element.\n  if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) {\n    return true;\n  }\n  const type = isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;\n\n  // Function component node\n  if (typeof type === 'function' && !type.prototype?.render && type.$$typeof !== ForwardRef) {\n    return false;\n  }\n\n  // Class component\n  if (typeof nodeOrComponent === 'function' && !nodeOrComponent.prototype?.render && nodeOrComponent.$$typeof !== ForwardRef) {\n    return false;\n  }\n  return true;\n};\nfunction isReactElement(node) {\n  return /*#__PURE__*/isValidElement(node) && !isFragment(node);\n}\nexport const supportNodeRef = node => {\n  return isReactElement(node) && supportRef(node);\n};\n\n/**\n * In React 19. `ref` is not a property from node.\n * But a property from `props.ref`.\n * To check if `props.ref` exist or fallback to `ref`.\n */\nexport const getNodeRef = node => {\n  if (node && isReactElement(node)) {\n    const ele = node;\n\n    // Source from:\n    // https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/getReactNodeRef/getReactNodeRef.ts\n    return ele.props.propertyIsEnumerable('ref') ? ele.props.ref : ele.ref;\n  }\n  return null;\n};","import * as React from 'react';\nexport default function useMemo(getValue, condition, shouldUpdate) {\n  const cacheRef = React.useRef({});\n  if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {\n    cacheRef.current.value = getValue();\n    cacheRef.current.condition = condition;\n  }\n  return cacheRef.current.value;\n}","const REACT_ELEMENT_TYPE_18 = Symbol.for('react.element');\nconst REACT_ELEMENT_TYPE_19 = Symbol.for('react.transitional.element');\nconst REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n\n/**\n * Compatible with React 18 or 19 to check if node is a Fragment.\n */\nexport default function isFragment(object) {\n  return (\n    // Base object type\n    object && typeof object === 'object' && (\n    // React Element type\n    object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) &&\n    // React Fragment type\n    object.type === REACT_FRAGMENT_TYPE\n  );\n}","export default function get(entity, path) {\n  let current = entity;\n  for (let i = 0; i < path.length; i += 1) {\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n    current = current[path[i]];\n  }\n  return current;\n}","import get from \"./get\";\nfunction internalSet(entity, paths, value, removeIfUndefined) {\n  if (!paths.length) {\n    return value;\n  }\n  const [path, ...restPath] = paths;\n  let clone;\n  if (!entity && typeof path === 'number') {\n    clone = [];\n  } else if (Array.isArray(entity)) {\n    clone = [...entity];\n  } else {\n    clone = {\n      ...entity\n    };\n  }\n\n  // Delete prop if `removeIfUndefined` and value is undefined\n  if (removeIfUndefined && value === undefined && restPath.length === 1) {\n    delete clone[path][restPath[0]];\n  } else {\n    clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);\n  }\n  return clone;\n}\nexport default function set(entity, paths, value, removeIfUndefined = false) {\n  // Do nothing if `removeIfUndefined` and parent object not exist\n  if (paths.length && removeIfUndefined && value === undefined && !get(entity, paths.slice(0, -1))) {\n    return entity;\n  }\n  return internalSet(entity, paths, value, removeIfUndefined);\n}\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\nfunction createEmpty(source) {\n  return Array.isArray(source) ? [] : {};\n}\nconst keys = typeof Reflect === 'undefined' ? Object.keys : Reflect.ownKeys;\n\n// ================================ Merge ================================\n\n/**\n * Merge multiple objects. Support custom merge logic.\n * @param sources object sources\n * @param config.prepareArray Customize array prepare function.\n * It will return empty [] by default.\n * So when match array, it will auto be override with next array in sources.\n */\nexport function mergeWith(sources, config = {}) {\n  const {\n    prepareArray\n  } = config;\n  const finalPrepareArray = prepareArray || (() => []);\n  let clone = createEmpty(sources[0]);\n  sources.forEach(src => {\n    function internalMerge(path, parentLoopSet) {\n      const loopSet = new Set(parentLoopSet);\n      const value = get(src, path);\n      const isArr = Array.isArray(value);\n      if (isArr || isObject(value)) {\n        // Only add not loop obj\n        if (!loopSet.has(value)) {\n          loopSet.add(value);\n          const originValue = get(clone, path);\n          if (isArr) {\n            // Array will always be override\n            clone = set(clone, path, finalPrepareArray(originValue, value));\n          } else if (!originValue || typeof originValue !== 'object') {\n            // Init container if not exist\n            clone = set(clone, path, createEmpty(value));\n          }\n          keys(value).forEach(key => {\n            if (Object.getOwnPropertyDescriptor(value, key).enumerable) {\n              internalMerge([...path, key], loopSet);\n            }\n          });\n        }\n      } else {\n        clone = set(clone, path, value);\n      }\n    }\n    internalMerge([]);\n  });\n  return clone;\n}\n\n/**\n * Merge multiple objects into a new single object.\n * Arrays will be replaced by default.\n */\nexport function merge(...sources) {\n  return mergeWith(sources);\n}","/* eslint-disable no-console */\nlet warned = {};\nconst preWarningFns = [];\n\n/**\n * Pre warning enable you to parse content before console.error.\n * Modify to null will prevent warning.\n */\nexport const preMessage = fn => {\n  preWarningFns.push(fn);\n};\n\n/**\n * Warning if condition not match.\n * @param valid Condition\n * @param message Warning message\n * @example\n * ```js\n * warning(false, 'some error'); // print some error\n * warning(true, 'some error'); // print nothing\n * warning(1 === 2, 'some error'); // print some error\n * ```\n */\nexport function warning(valid, message) {\n  if (process.env.NODE_ENV !== 'production' && !valid && console !== undefined) {\n    const finalMessage = preWarningFns.reduce((msg, preMessageFn) => preMessageFn(msg ?? '', 'warning'), message);\n    if (finalMessage) {\n      console.error(`Warning: ${finalMessage}`);\n    }\n  }\n}\n\n/** @see Similar to {@link warning} */\nexport function note(valid, message) {\n  if (process.env.NODE_ENV !== 'production' && !valid && console !== undefined) {\n    const finalMessage = preWarningFns.reduce((msg, preMessageFn) => preMessageFn(msg ?? '', 'note'), message);\n    if (finalMessage) {\n      console.warn(`Note: ${finalMessage}`);\n    }\n  }\n}\nexport function resetWarned() {\n  warned = {};\n}\nexport function call(method, valid, message) {\n  if (!valid && !warned[message]) {\n    method(false, message);\n    warned[message] = true;\n  }\n}\n\n/** @see Same as {@link warning}, but only warn once for the same message */\nexport function warningOnce(valid, message) {\n  call(warning, valid, message);\n}\n\n/** @see Same as {@link warning}, but only warn once for the same message */\nexport function noteOnce(valid, message) {\n  call(note, valid, message);\n}\nwarningOnce.preMessage = preMessage;\nwarningOnce.resetWarned = resetWarned;\nwarningOnce.noteOnce = noteOnce;\nexport default warningOnce;","export default function omit(obj, fields) {\n  const clone = Object.assign({}, obj);\n  if (Array.isArray(fields)) {\n    fields.forEach(key => {\n      delete clone[key];\n    });\n  }\n  return clone;\n}","import isFragment from \"../React/isFragment\";\nimport React from 'react';\nexport default function toArray(children, option = {}) {\n  let ret = [];\n  React.Children.forEach(children, child => {\n    if ((child === undefined || child === null) && !option.keepEmpty) {\n      return;\n    }\n    if (Array.isArray(child)) {\n      ret = ret.concat(toArray(child));\n    } else if (isFragment(child) && child.props) {\n      ret = ret.concat(toArray(child.props.children, option));\n    } else {\n      ret.push(child);\n    }\n  });\n  return ret;\n}","import { useEffect, useState, useSyncExternalStore } from 'react';\n\nexport type ConversationKey = string | number | symbol;\n\nexport const chatMessagesStoreHelper = {\n  _chatMessagesStores: new Map<ConversationKey, ChatMessagesStore<any>>(),\n  get: (conversationKey: ConversationKey) => {\n    return chatMessagesStoreHelper._chatMessagesStores.get(conversationKey);\n  },\n  set: (key: ConversationKey, store: ChatMessagesStore<any>) => {\n    chatMessagesStoreHelper._chatMessagesStores.set(key, store);\n  },\n  delete: (key: ConversationKey) => {\n    chatMessagesStoreHelper._chatMessagesStores.delete(key);\n  },\n  getMessages: (conversationKey: ConversationKey) => {\n    const store = chatMessagesStoreHelper._chatMessagesStores.get(conversationKey);\n    return store?.getMessages();\n  },\n};\n\nexport class ChatMessagesStore<T extends { id: number | string }> {\n  private listeners: (() => void)[] = [];\n  private conversationKey: ConversationKey | undefined;\n  private snapshotResult: {\n    messages: T[];\n    isDefaultMessagesRequesting: boolean;\n  } = {\n    messages: [],\n    isDefaultMessagesRequesting: false,\n  };\n  // Throttle state for preventing \"Maximum update depth exceeded\" during streaming\n  private throttleTimer: ReturnType<typeof setTimeout> | null = null;\n  private pendingEmit = false;\n  private readonly throttleInterval: number = 50;\n  // 竞态条件保护\n  private isDestroyed = false;\n\n  private emitListeners() {\n    this.listeners.forEach((listener) => {\n      listener();\n    });\n  }\n\n  private throttledEmitListeners() {\n    if (!this.throttleTimer) {\n      // Leading edge: execute immediately\n      this.emitListeners();\n      this.pendingEmit = false;\n\n      this.throttleTimer = setTimeout(() => {\n        this.throttleTimer = null;\n        // Trailing edge: flush pending updates\n        if (this.pendingEmit) {\n          this.emitListeners();\n          this.pendingEmit = false;\n        }\n      }, this.throttleInterval);\n    } else {\n      this.pendingEmit = true;\n    }\n  }\n\n  constructor(defaultMessages: () => Promise<T[]>, conversationKey?: ConversationKey) {\n    // 初始化消息，处理同步和异步情况\n    this.initializeMessages(defaultMessages, (value) => {\n      this.setSnapshotResult('isDefaultMessagesRequesting', value);\n      this.emitListeners();\n    });\n\n    // 注册到全局存储助手\n    if (conversationKey) {\n      this.conversationKey = conversationKey;\n      chatMessagesStoreHelper.set(this.conversationKey, this);\n    }\n  }\n\n  private async initializeMessages(\n    defaultMessages: () => Promise<T[]>,\n    setDefaultMessagesRequesting: (defaultValueLoading: boolean) => void,\n  ) {\n    try {\n      setDefaultMessagesRequesting(true);\n      const messages = await defaultMessages();\n\n      // 检查是否已被销毁，避免竞态条件\n      if (!this.isDestroyed) {\n        this.setMessagesInternal(messages, false);\n      }\n    } catch (error) {\n      // 错误处理：保持空数组状态，避免应用崩溃\n      console.warn('Failed to initialize messages:', error);\n      if (!this.isDestroyed) {\n        this.setMessagesInternal([], false);\n      }\n    } finally {\n      setDefaultMessagesRequesting(false);\n    }\n  }\n  private setSnapshotResult = <K extends keyof typeof this.snapshotResult>(\n    key: K,\n    value: (typeof this.snapshotResult)[K],\n  ) => {\n    this.snapshotResult = {\n      ...this.snapshotResult,\n      [key]: value,\n    };\n  };\n  private setMessagesInternal = (messages: T[] | ((ori: T[]) => T[]), throttle = true) => {\n    let list: T[];\n    if (typeof messages === 'function') {\n      list = messages(this.snapshotResult.messages);\n    } else {\n      list = messages as T[];\n    }\n    this.setSnapshotResult('messages', list);\n\n    if (throttle) {\n      this.throttledEmitListeners();\n    } else {\n      this.emitListeners();\n    }\n    return true;\n  };\n\n  setMessages = (messages: T[] | ((ori: T[]) => T[])) => {\n    return this.setMessagesInternal(messages, true);\n  };\n\n  getMessages = () => {\n    return this.snapshotResult.messages;\n  };\n\n  getMessage = (id: string | number) => {\n    return this.getMessages().find((item) => item.id === id);\n  };\n\n  addMessage = (message: T) => {\n    const exist = this.getMessage(message.id);\n    if (!exist) {\n      this.setMessages([...this.snapshotResult.messages, message]);\n      return true;\n    }\n    return false;\n  };\n\n  setMessage = (id: string | number, message: Partial<T> | ((message: T) => Partial<T>)) => {\n    const originMessage = this.getMessage(id);\n    if (originMessage) {\n      const mergeMessage = typeof message === 'function' ? message(originMessage) : message;\n      Object.assign(originMessage, mergeMessage);\n      this.setMessages([...this.snapshotResult.messages]);\n      return true;\n    }\n    return false;\n  };\n\n  removeMessage = (id: string | number) => {\n    const index = this.getMessages().findIndex((item) => item.id === id);\n    if (index !== -1) {\n      this.snapshotResult.messages.splice(index, 1);\n      this.setMessages([...this.getMessages()]);\n      return true;\n    }\n    return false;\n  };\n\n  getSnapshot = () => {\n    return this.snapshotResult;\n  };\n\n  subscribe = (callback: () => void) => {\n    this.listeners.push(callback);\n    return () => {\n      this.listeners = this.listeners.filter((listener) => listener !== callback);\n      // Clean up throttle timer when no listeners remain to prevent memory leaks\n      // and \"setState on unmounted component\" warnings\n      if (this.listeners.length === 0) {\n        if (this.throttleTimer) {\n          clearTimeout(this.throttleTimer);\n          this.throttleTimer = null;\n        }\n        this.pendingEmit = false;\n      }\n    };\n  };\n\n  /**\n   * Clean up resources (throttle timer) when the store is no longer needed.\n   * Should be called when the component unmounts or the store is disposed.\n   */\n  destroy = () => {\n    this.isDestroyed = true;\n    if (this.throttleTimer) {\n      clearTimeout(this.throttleTimer);\n      this.throttleTimer = null;\n    }\n    this.pendingEmit = false;\n    this.listeners = [];\n  };\n}\n\nexport function useChatStore<T extends { id: number | string }>(\n  defaultValue: () => Promise<T[]>,\n  conversationKey: ConversationKey,\n) {\n  const createStore = () => {\n    if (chatMessagesStoreHelper.get(conversationKey)) {\n      return chatMessagesStoreHelper.get(conversationKey) as ChatMessagesStore<T>;\n    }\n\n    const store = new ChatMessagesStore<T>(defaultValue, conversationKey);\n    return store;\n  };\n  const [store, setStore] = useState(createStore);\n\n  useEffect(() => {\n    setStore(createStore());\n  }, [conversationKey]);\n\n  const { messages, isDefaultMessagesRequesting } = useSyncExternalStore(\n    store.subscribe,\n    store.getSnapshot,\n    store.getSnapshot,\n  );\n\n  return {\n    messages,\n    isDefaultMessagesRequesting,\n    addMessage: store.addMessage,\n    removeMessage: store.removeMessage,\n    setMessage: store.setMessage,\n    getMessage: store.getMessage,\n    setMessages: store.setMessages,\n    getMessages: store.getMessages,\n  };\n}\n","import { useEvent } from '@rc-component/util';\nimport React, { useEffect, useState } from 'react';\nimport type { AnyObject } from '../_util/type';\nimport { AbstractChatProvider } from '../chat-providers';\nimport { ConversationData } from '../x-conversations';\nimport { AbstractXRequestClass } from '../x-request';\nimport type { SSEOutput } from '../x-stream';\nimport { ConversationKey, useChatStore } from './store';\n\nexport type SimpleType = string | number | boolean | object;\n\nenum MessageStatusEnum {\n  local = 'local',\n  loading = 'loading',\n  updating = 'updating',\n  success = 'success',\n  error = 'error',\n  abort = 'abort',\n}\n\nexport type MessageStatus = `${MessageStatusEnum}`;\n\ntype RequestPlaceholderFn<Input, Message> = (\n  requestParams: Partial<Input>,\n  info: { messages: Message[] },\n) => Message;\n\ntype RequestFallbackFn<Input, MessageInfo, Message> = (\n  requestParams: Partial<Input>,\n  info: { error: Error; errorInfo?: any; messages: Message[]; messageInfo: MessageInfo },\n) => Message | Promise<Message>;\n\nexport type RequestParams<Message> = {\n  [Key: PropertyKey]: Message;\n} & AnyObject;\n\nexport interface XChatConfig<\n  ChatMessage extends SimpleType = string,\n  BubbleMessage extends SimpleType = ChatMessage,\n  Input = ChatMessage,\n  Output = ChatMessage,\n> {\n  provider?: AbstractChatProvider<ChatMessage, Input, Output>;\n  conversationKey?: ConversationData['key'];\n  defaultMessages?:\n    | DefaultMessageInfo<ChatMessage>[]\n    | ((info: {\n        conversationKey?: ConversationData['key'];\n      }) => Promise<DefaultMessageInfo<ChatMessage>[]>)\n    | ((info?: { conversationKey?: ConversationData['key'] }) => DefaultMessageInfo<ChatMessage>[]);\n  /** Convert agent message to bubble usage message type */\n  parser?: (message: ChatMessage) => BubbleMessage | BubbleMessage[];\n  requestPlaceholder?: ChatMessage | RequestPlaceholderFn<Input, ChatMessage>;\n  requestFallback?: ChatMessage | RequestFallbackFn<Input, MessageInfo<ChatMessage>, ChatMessage>;\n}\n\nexport interface MessageInfo<Message extends SimpleType> {\n  id: number | string;\n  message: Message;\n  status: MessageStatus;\n  extraInfo?: AnyObject;\n}\n\nexport type DefaultMessageInfo<Message extends SimpleType> = Pick<MessageInfo<Message>, 'message'> &\n  Partial<Omit<MessageInfo<Message>, 'message'>>;\n\nexport type RequestResultObject<Message> = {\n  message: Message | Message[];\n  status: MessageStatus;\n};\n\nexport type StandardRequestResult<Message extends SimpleType> = Omit<\n  RequestResultObject<Message>,\n  'message' | 'status'\n> & {\n  message: Message;\n  status?: MessageStatus;\n};\n\nfunction toArray<T>(item: T | T[]): T[] {\n  return Array.isArray(item) ? item : [item];\n}\n\nconst IsRequestingMap = new Map<ConversationKey, boolean>();\nconst generateConversationKey = () => Symbol('ConversationKey');\n\nexport default function useXChat<\n  ChatMessage extends SimpleType = string,\n  ParsedMessage extends SimpleType = ChatMessage,\n  Input = RequestParams<ChatMessage>,\n  Output = SSEOutput,\n>(config: XChatConfig<ChatMessage, ParsedMessage, Input, Output>) {\n  const {\n    defaultMessages,\n    requestFallback,\n    requestPlaceholder,\n    parser,\n    provider,\n    conversationKey: originalConversationKey,\n  } = config;\n\n  // ========================= Agent Messages =========================\n  const idRef = React.useRef(0);\n  const requestHandlerRef =\n    React.useRef<AbstractXRequestClass<Input, Output, ChatMessage>>(undefined);\n  const [isRequesting, setIsRequesting] = useState<boolean>(false);\n  // fix #1431, should give a default key to create store\n  const [conversationKey, setConversationKey] = useState(\n    originalConversationKey || generateConversationKey(),\n  );\n\n  useEffect(() => {\n    if (originalConversationKey) {\n      setConversationKey(originalConversationKey);\n    }\n  }, [originalConversationKey]);\n\n  const {\n    messages,\n    isDefaultMessagesRequesting,\n    removeMessage,\n    setMessages,\n    getMessages,\n    setMessage,\n  } = useChatStore<MessageInfo<ChatMessage>>(async () => {\n    const messageList =\n      typeof defaultMessages === 'function'\n        ? await defaultMessages({ conversationKey: originalConversationKey })\n        : defaultMessages;\n    return (messageList || []).map((info, index) => ({\n      id: `default_${index}`,\n      status: 'local',\n      ...info,\n    }));\n  }, conversationKey);\n\n  const createMessage = (message: ChatMessage, status: MessageStatus, extraInfo?: AnyObject) => {\n    const msg: MessageInfo<ChatMessage> = {\n      id: `msg_${idRef.current}`,\n      message,\n      status,\n    };\n    if (extraInfo) {\n      msg.extraInfo = extraInfo;\n    }\n    idRef.current += 1;\n\n    return msg;\n  };\n\n  // ========================= BubbleMessages =========================\n  const parsedMessages = React.useMemo(() => {\n    const list: MessageInfo<ParsedMessage>[] = [];\n\n    messages.forEach((agentMsg) => {\n      const rawParsedMsg = parser ? parser(agentMsg.message) : agentMsg.message;\n      const bubbleMsgs = toArray(rawParsedMsg as ParsedMessage);\n\n      bubbleMsgs.forEach((bubbleMsg, bubbleMsgIndex) => {\n        let key = agentMsg.id;\n        if (bubbleMsgs.length > 1) {\n          key = `${key}_${bubbleMsgIndex}`;\n        }\n\n        list.push({\n          id: key,\n          message: bubbleMsg,\n          status: agentMsg.status,\n        });\n      });\n    });\n\n    return list;\n  }, [messages]);\n\n  // ============================ Request =============================\n  const getFilteredMessages = (msgs: MessageInfo<ChatMessage>[]) =>\n    msgs.filter((info) => info.status !== 'loading').map((info) => info.message);\n\n  provider?.injectGetMessages(() => {\n    return getFilteredMessages(getMessages());\n  });\n  requestHandlerRef.current = provider?.request;\n  // For agent to use. Will filter out loading and error message\n  const getRequestMessages = () => getFilteredMessages(getMessages());\n\n  const innerOnRequest = (\n    requestParams: Partial<Input>,\n    opts?: {\n      updatingId?: number | string;\n      reload?: boolean;\n      extraInfo?: AnyObject;\n    },\n  ) => {\n    if (!provider) {\n      return;\n    }\n    const { updatingId, reload } = opts || {};\n    let loadingMsgId: number | string | null | undefined = null;\n    const localMessage = provider.transformLocalMessage(requestParams);\n    const messages = (Array.isArray(localMessage) ? localMessage : [localMessage]).map((message) =>\n      createMessage(message, 'local', opts?.extraInfo),\n    );\n    if (reload) {\n      loadingMsgId = updatingId;\n      setMessages((ori: MessageInfo<ChatMessage>[]) => {\n        const nextMessages = [...ori];\n        if (requestPlaceholder) {\n          let placeholderMsg: ChatMessage;\n          if (typeof requestPlaceholder === 'function') {\n            // typescript has bug that not get real return type when use `typeof function` check\n            placeholderMsg = (requestPlaceholder as RequestPlaceholderFn<Input, ChatMessage>)(\n              requestParams,\n              {\n                messages: getFilteredMessages(nextMessages),\n              },\n            );\n          } else {\n            placeholderMsg = requestPlaceholder;\n          }\n          nextMessages.forEach((info) => {\n            if (info.id === updatingId) {\n              info.status = 'loading';\n              info.message = placeholderMsg;\n              if (opts?.extraInfo) {\n                info.extraInfo = opts?.extraInfo;\n              }\n            }\n          });\n        }\n        return nextMessages;\n      });\n    } else {\n      // Add placeholder message\n      setMessages((ori: MessageInfo<ChatMessage>[]) => {\n        let nextMessages = [...ori, ...messages];\n        if (requestPlaceholder) {\n          let placeholderMsg: ChatMessage;\n          if (typeof requestPlaceholder === 'function') {\n            // typescript has bug that not get real return type when use `typeof function` check\n            placeholderMsg = (requestPlaceholder as RequestPlaceholderFn<Input, ChatMessage>)(\n              requestParams,\n              {\n                messages: getFilteredMessages(nextMessages),\n              },\n            );\n          } else {\n            placeholderMsg = requestPlaceholder;\n          }\n          const loadingMsg = createMessage(placeholderMsg, 'loading');\n          loadingMsgId = loadingMsg.id;\n\n          nextMessages = [...nextMessages, loadingMsg];\n        }\n\n        return nextMessages;\n      });\n    }\n\n    // Request\n    let updatingMsgId: number | string | null | undefined = null;\n    const updateMessage = (\n      status: MessageStatus,\n      chunk: Output,\n      chunks: Output[],\n      responseHeaders: Headers,\n    ) => {\n      let msg = getMessages().find((info) => info.id === updatingMsgId);\n      if (!msg) {\n        if (reload && updatingId) {\n          msg = getMessages().find((info) => info.id === updatingId);\n          if (msg) {\n            msg.status = status;\n            msg.message = provider.transformMessage({ chunk, status, chunks, responseHeaders });\n            setMessages((ori: MessageInfo<ChatMessage>[]) => {\n              return [...ori];\n            });\n            updatingMsgId = msg.id;\n          }\n        } else {\n          // Create if not exist\n          const transformData = provider.transformMessage({\n            chunk,\n            status,\n            chunks,\n            responseHeaders,\n          });\n          msg = createMessage(transformData, status);\n          setMessages((ori: MessageInfo<ChatMessage>[]) => {\n            const oriWithoutPending = ori.filter(\n              (info: { id: string | number | null | undefined }) => info.id !== loadingMsgId,\n            );\n            return [...oriWithoutPending, msg!];\n          });\n          updatingMsgId = msg.id;\n        }\n      } else {\n        // Update directly\n        setMessages((ori: MessageInfo<ChatMessage>[]) => {\n          return ori.map((info: MessageInfo<ChatMessage>) => {\n            if (info.id === updatingMsgId) {\n              const transformData = provider.transformMessage({\n                originMessage: info.message,\n                chunk,\n                chunks,\n                status,\n                responseHeaders,\n              });\n              return {\n                ...info,\n                message: transformData,\n                status,\n              };\n            }\n            return info;\n          });\n        });\n      }\n      msg = getMessages().find((info) => info.id === updatingMsgId) || msg;\n      return msg;\n    };\n    provider.injectRequest({\n      onUpdate: (chunk: Output, headers: Headers) => {\n        const msg = updateMessage('updating', chunk, [], headers);\n        return msg;\n      },\n      onSuccess: (chunks: Output[], headers: Headers) => {\n        setIsRequesting(false);\n        conversationKey && IsRequestingMap.delete(conversationKey);\n        const msg = updateMessage('success', undefined as Output, chunks, headers);\n        return msg;\n      },\n      onError: async (error: Error, errorInfo: any) => {\n        setIsRequesting(false);\n        conversationKey && IsRequestingMap.delete(conversationKey);\n        let fallbackMsg: ChatMessage;\n        if (requestFallback) {\n          // Update as error\n          if (typeof requestFallback === 'function') {\n            // typescript has bug that not get real return type when use `typeof function` check\n            const messages = getRequestMessages();\n            const msg = getMessages().find(\n              (info) => info.id === loadingMsgId || info.id === updatingMsgId,\n            );\n\n            fallbackMsg = await (\n              requestFallback as RequestFallbackFn<Input, MessageInfo<ChatMessage>, ChatMessage>\n            )(requestParams, {\n              error,\n              errorInfo,\n              messageInfo: msg as MessageInfo<ChatMessage>,\n              messages,\n            });\n          } else {\n            fallbackMsg = requestFallback;\n          }\n          setMessages((ori: MessageInfo<ChatMessage>[]) => [\n            ...ori.filter(\n              (info: { id: string | number | null | undefined }) =>\n                info.id !== loadingMsgId && info.id !== updatingMsgId,\n            ),\n            createMessage(fallbackMsg, error.name === 'AbortError' ? 'abort' : 'error'),\n          ]);\n        } else {\n          // Remove directly\n          fallbackMsg = getMessages().find(\n            (info) => info.id !== loadingMsgId && info.id !== updatingMsgId,\n          ) as ChatMessage;\n          setMessages((ori: MessageInfo<ChatMessage>[]) => {\n            return ori.map((info: MessageInfo<ChatMessage>) => {\n              if (info.id === loadingMsgId || info.id === updatingMsgId) {\n                return {\n                  ...info,\n                  status: error.name === 'AbortError' ? 'abort' : 'error',\n                };\n              }\n              return info;\n            });\n          });\n        }\n        return fallbackMsg;\n      },\n    });\n    setIsRequesting(true);\n    conversationKey && IsRequestingMap.set(conversationKey, true);\n    provider.request.run(provider.transformParams(requestParams, provider.request.options));\n  };\n\n  const onRequest = useEvent((requestParams: Partial<Input>, opts?: { extraInfo: AnyObject }) => {\n    if (!provider) {\n      throw new Error('provider is required');\n    }\n    innerOnRequest(requestParams, opts);\n  });\n\n  const onReload = (\n    id: string | number,\n    requestParams: Partial<Input>,\n    opts?: { extraInfo: AnyObject },\n  ) => {\n    if (!provider) {\n      throw new Error('provider is required');\n    }\n    if (!id || !getMessages().find((info) => info.id === id)) {\n      throw new Error(`message [${id}] is not found`);\n    }\n    innerOnRequest(requestParams, {\n      updatingId: id,\n      reload: true,\n      extraInfo: opts?.extraInfo,\n    });\n  };\n\n  return {\n    onRequest,\n    isDefaultMessagesRequesting,\n    messages,\n    parsedMessages,\n    setMessages,\n    removeMessage,\n    setMessage,\n    abort: () => {\n      if (!provider) {\n        throw new Error('provider is required');\n      }\n      requestHandlerRef.current?.abort();\n    },\n    isRequesting: conversationKey ? IsRequestingMap?.get(conversationKey) || false : isRequesting,\n    onReload,\n  } as const;\n}\n","import { chatMessagesStoreHelper } from '../x-chat/store';\nimport type { ConversationData } from '.';\n\n/**\n * We manage all conversation stores here, so that useXChat can get the conversation data by conversationKey.\n */\nexport const conversationStoreHelper = {\n  _allConversationStores: new Map<string, ConversationStore>(),\n  set: (key: string, store: ConversationStore) => {\n    conversationStoreHelper._allConversationStores.set(key, store);\n  },\n  delete: (key: string) => {\n    conversationStoreHelper._allConversationStores.delete(key);\n  },\n  getConversation: (conversationKey: string) => {\n    for (const store of conversationStoreHelper._allConversationStores.values()) {\n      if (store) {\n        const conversation = store.getConversation(conversationKey);\n        if (conversation) {\n          return conversation;\n        }\n      }\n    }\n  },\n};\n\nexport class ConversationStore {\n  private conversations: ConversationData[] = [];\n  private listeners: (() => void)[] = [];\n  private storeKey: string;\n  private activeConversationKey: string;\n\n  private emitListeners() {\n    this.listeners.forEach((listener) => {\n      listener();\n    });\n  }\n\n  constructor(defaultConversations: ConversationData[], defaultActiveConversationKey: string) {\n    this.setConversations(defaultConversations);\n    this.storeKey = Math.random().toString();\n    conversationStoreHelper.set(this.storeKey, this);\n    this.activeConversationKey = defaultActiveConversationKey;\n  }\n\n  setActiveConversationKey = (key: string) => {\n    this.activeConversationKey = key;\n    this.emitListeners();\n    return true;\n  };\n  setConversations = (list: ConversationData[]) => {\n    this.conversations = [...list];\n    this.emitListeners();\n    return true;\n  };\n\n  getConversation = (key: ConversationData['key']) => {\n    return this.conversations.find((item) => item.key === key);\n  };\n\n  addConversation = (conversation: ConversationData, placement?: 'prepend' | 'append') => {\n    const exist = this.getConversation(conversation.key);\n    if (!exist) {\n      this.setConversations(\n        placement === 'prepend'\n          ? [conversation, ...this.conversations]\n          : [...this.conversations, conversation],\n      );\n      return true;\n    }\n    return false;\n  };\n\n  setConversation = (key: ConversationData['key'], conversation: ConversationData) => {\n    const exist = this.getConversation(key);\n    if (exist) {\n      Object.assign(exist, conversation);\n      this.setConversations([...this.conversations]);\n      return true;\n    }\n    return false;\n  };\n\n  removeConversation = (key: ConversationData['key']) => {\n    const index = this.conversations.findIndex((item) => item.key === key);\n    if (index !== -1) {\n      this.conversations.splice(index, 1);\n      this.setConversations([...this.conversations]);\n      return true;\n    }\n    return false;\n  };\n\n  getMessages = (key: ConversationData['key']) => {\n    return chatMessagesStoreHelper.getMessages(key);\n  };\n\n  getSnapshot = () => {\n    return this.conversations;\n  };\n\n  getActiveConversationKey = () => {\n    return this.activeConversationKey;\n  };\n\n  subscribe = (callback: () => void) => {\n    this.listeners.push(callback);\n    return () => {\n      this.listeners = this.listeners.filter((listener) => listener !== callback);\n    };\n  };\n\n  destroy = () => {\n    conversationStoreHelper.delete(this.storeKey);\n  };\n}\n","import { useEffect, useState, useSyncExternalStore } from 'react';\nimport { AnyObject } from '../_util/type';\nimport { ConversationStore } from './store';\n\nexport interface ConversationData extends AnyObject {\n  key: string;\n}\n\ninterface XConversationConfig {\n  defaultConversations?: ConversationData[];\n  defaultActiveConversationKey?: string;\n}\n\nexport default function useXConversations(config: XConversationConfig) {\n  const [store] = useState(() => {\n    const store = new ConversationStore(\n      config?.defaultConversations || [],\n      config?.defaultActiveConversationKey || '',\n    );\n    return store;\n  });\n\n  useEffect(() => {\n    return () => {\n      store.destroy();\n    };\n  }, []);\n\n  const conversations = useSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n  const activeConversationKey = useSyncExternalStore(\n    store.subscribe,\n    store.getActiveConversationKey,\n    store.getActiveConversationKey,\n  );\n\n  return {\n    conversations,\n    activeConversationKey: activeConversationKey,\n    setActiveConversationKey: store.setActiveConversationKey,\n    addConversation: store.addConversation,\n    removeConversation: store.removeConversation,\n    setConversation: store.setConversation,\n    getConversation: store.getConversation,\n    setConversations: store.setConversations,\n    getMessages: store.getMessages,\n  };\n}\n","/**\n * @description default separator for {@link splitStream}\n */\nconst DEFAULT_STREAM_SEPARATOR = '\\n\\n';\n/**\n * @description Default separator for {@link splitPart}\n * @example \"event: delta\\ndata: {\\\"key\\\": \\\"value\\\"}\"\n */\nconst DEFAULT_PART_SEPARATOR = '\\n';\n/**\n * @description Default separator for key value, A colon (`:`) is used to separate keys from values\n * @example \"event: delta\"\n */\nconst DEFAULT_KV_SEPARATOR = ':';\n\n/**\n * Check if a string is not empty or only contains whitespace characters\n */\nconst isValidString = (str: string) => (str ?? '').trim() !== '';\n\n/**\n * @description A TransformStream inst that splits a stream into parts based on {@link DEFAULT_STREAM_SEPARATOR}\n * @example\n *\n * `event: delta\n * data: { content: 'hello' }\n *\n * event: delta\n * data: { key: 'world!' }\n *\n * `\n */\nfunction splitStream(streamSeparator = DEFAULT_STREAM_SEPARATOR) {\n  // Buffer to store incomplete data chunks between transformations\n  let buffer = '';\n\n  return new TransformStream<string, string>({\n    transform(streamChunk, controller) {\n      buffer += streamChunk;\n\n      // Split the buffer based on the separator\n      const parts = buffer.split(streamSeparator);\n      // Enqueue all complete parts except for the last incomplete one\n      parts.slice(0, -1).forEach((part) => {\n        // Skip empty parts\n        if (isValidString(part)) {\n          controller.enqueue(part);\n        }\n      });\n\n      // Save the last incomplete part back to the buffer for the next chunk\n      buffer = parts[parts.length - 1];\n    },\n    flush(controller) {\n      // If there's any remaining data in the buffer, enqueue it as the final part\n      if (isValidString(buffer)) {\n        controller.enqueue(buffer);\n      }\n    },\n  });\n}\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#fields\n */\nexport type SSEFields = 'data' | 'event' | 'id' | 'retry';\n\n/**\n * @example\n * const sseObject = {\n *    event: 'delta',\n *    data: '{ key: \"world!\" }',\n * };\n */\nexport type SSEOutput = Partial<Record<SSEFields, any>>;\n\nexport interface JSONOutPut extends Partial<Record<SSEFields, any>> {\n  success: boolean;\n  message?: string;\n  name?: string;\n}\n\n/**\n * @description A TransformStream inst that transforms a part string into {@link SSEOutput}\n * @example part string\n *\n * \"event: delta\\ndata: { key: 'world!' }\\n\"\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/EventSource\n *\n * When handling responses with `Content-Type: text/event-stream`, the following standard practices are commonly observed:\n * - Double newline characters (`\\n\\n`) are used to separate individual events.\n * - Single newline characters (`\\n`) are employed to separate line within an event.\n */\nfunction splitPart(partSeparator = DEFAULT_PART_SEPARATOR, kvSeparator = DEFAULT_KV_SEPARATOR) {\n  return new TransformStream<string, SSEOutput>({\n    transform(partChunk, controller) {\n      // Split the chunk into key-value pairs using the partSeparator\n      const lines = partChunk.split(partSeparator);\n      const sseEvent = lines.reduce<SSEOutput>((acc, line) => {\n        const separatorIndex = line.indexOf(kvSeparator);\n\n        if (separatorIndex === -1) {\n          console.warn(\n            `The key-value separator \"${kvSeparator}\" is not found in the sse line: ${line} !`,\n          );\n          return acc;\n        }\n\n        // Extract the key from the beginning of the line up to the separator\n        const key = line.slice(0, separatorIndex).trim();\n\n        // The colon is used for comment lines, skip directly\n        if (!isValidString(key)) return acc;\n\n        // Extract the value from the line after the separator\n        const value = line.slice(separatorIndex + 1).trim();\n\n        return { ...acc, [key]: value };\n      }, {});\n\n      if (Object.keys(sseEvent).length === 0) return;\n\n      // Reduce the key-value pairs into a single object and enqueue\n      controller.enqueue(sseEvent);\n    },\n  });\n}\n\nexport interface XStreamOptions<Output> {\n  /**\n   * @description Readable stream of binary data\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\n   */\n  readableStream: ReadableStream<Uint8Array>;\n\n  /**\n   * @description Support customizable transformStream to transform streams\n   * @default sseTransformStream\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/TransformStream\n   */\n  transformStream?: TransformStream<string, Output>;\n  /**\n   * @description Separator for stream data parsing\n   */\n  streamSeparator?: string;\n  /**\n   * @description Separator for different parts within the stream\n   */\n  partSeparator?: string;\n  /**\n   * @description Separator for key-value pairs in the stream data\n   */\n  kvSeparator?: string;\n}\n\nexport type XReadableStream<R = SSEOutput> = ReadableStream<R> & AsyncGenerator<R>;\n\nfunction createDecoderStream() {\n  if (typeof TextDecoderStream !== 'undefined') {\n    return new TextDecoderStream();\n  }\n\n  const decoder = new TextDecoder('utf-8');\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(decoder.decode(chunk, { stream: true }));\n    },\n    flush(controller) {\n      controller.enqueue(decoder.decode());\n    },\n  });\n}\n\n/**\n * @description Transform Uint8Array binary stream to {@link SSEOutput} by default\n * @warning The `XStream` only support the `utf-8` encoding. More encoding support maybe in the future.\n */\nfunction XStream<Output = SSEOutput>(options: XStreamOptions<Output>) {\n  const { readableStream, transformStream, streamSeparator, partSeparator, kvSeparator } = options;\n\n  if (!(readableStream instanceof ReadableStream)) {\n    throw new Error('The options.readableStream must be an instance of ReadableStream.');\n  }\n\n  // Default encoding is `utf-8`\n  const decoderStream = createDecoderStream();\n\n  const stream = (\n    transformStream\n      ? /**\n         * Uint8Array binary -> string -> Output\n         */\n        readableStream\n          .pipeThrough(decoderStream as TransformStream<Uint8Array, string>)\n          .pipeThrough(transformStream)\n      : /**\n         * Uint8Array binary -> string -> SSE part string -> Default Output {@link SSEOutput}\n         */\n        readableStream\n          .pipeThrough(decoderStream as TransformStream<Uint8Array, string>)\n          .pipeThrough(splitStream(streamSeparator))\n          .pipeThrough(splitPart(partSeparator, kvSeparator))\n  ) as XReadableStream<Output>;\n\n  /** support async iterator */\n  stream[Symbol.asyncIterator] = async function* () {\n    const reader = this.getReader();\n\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) break;\n\n      if (!value) continue;\n\n      // Transformed data through all transform pipes\n      yield value;\n    }\n  };\n\n  return stream;\n}\n\nexport default XStream;\n","import { XRequestOptions } from '.';\n\nexport interface XFetchMiddlewares<Input, Output> {\n  onRequest?: (\n    baseURL: Parameters<typeof fetch>[0],\n    options: XRequestOptions<Input, Output>,\n  ) => Promise<[Parameters<typeof fetch>[0], XRequestOptions<Input, Output>]>;\n  onResponse?: (response: Response) => Promise<Response>;\n}\n\nexport type XFetchType<Input, Output> = (\n  baseURL: Parameters<typeof fetch>[0],\n  options?: XRequestOptions<Input, Output>,\n) => Promise<Response>;\n\nconst XFetch = async <Input, Output>(\n  baseURL: Parameters<typeof fetch>[0],\n  options: XRequestOptions<Input, Output>,\n) => {\n  const { fetch: fetchFn = globalThis.fetch, middlewares = {}, ...requestInit } = options;\n\n  if (typeof fetchFn !== 'function') {\n    throw new Error('The options.fetch must be a typeof fetch function!');\n  }\n\n  /** ---------------------- request init ---------------------- */\n  let fetchArgs: [Parameters<typeof fetch>[0], XRequestOptions<Input, Output>] = [\n    baseURL,\n    requestInit,\n  ];\n\n  /** ---------------------- request middleware ---------------------- */\n  if (typeof middlewares.onRequest === 'function') {\n    const modifiedFetchArgs = await middlewares.onRequest(...fetchArgs);\n\n    fetchArgs = modifiedFetchArgs;\n  }\n\n  /** ---------------------- fetch ---------------------- */\n  let response = await fetchFn(...fetchArgs);\n\n  /** ---------------------- response middleware ---------------------- */\n  if (typeof middlewares.onResponse === 'function') {\n    const modifiedResponse = await middlewares.onResponse(response);\n\n    if (!(modifiedResponse instanceof Response)) {\n      throw new Error('The options.onResponse must return a Response instance!');\n    }\n\n    response = modifiedResponse;\n  }\n\n  /** ---------------------- response check ---------------------- */\n  if (!response.ok) {\n    throw new Error(`Fetch failed with status ${response.status}`);\n  }\n\n  if (!response.body) {\n    throw new Error('The response body is empty.');\n  }\n\n  /** ---------------------- return ---------------------- */\n  return response;\n};\n\nexport default XFetch;\n","import type { AnyObject } from '../_util/type';\nimport { MessageInfo, SimpleType } from '../x-chat';\nimport type { JSONOutPut, SSEOutput, XReadableStream, XStreamOptions } from '../x-stream';\nimport XStream from '../x-stream';\nimport type { XFetchMiddlewares } from './x-fetch';\nimport xFetch from './x-fetch';\n\nexport interface XRequestCallbacks<Output, ChatMessage extends SimpleType = any> {\n  /**\n   * @description Callback when the request is successful\n   */\n  onSuccess: (\n    chunks: Output[],\n    responseHeaders: Headers,\n    chatMessage?: MessageInfo<ChatMessage>,\n  ) => void;\n\n  /**\n   * @description Callback when the request fails\n   */\n  onError: (\n    error: Error,\n    errorInfo?: any,\n    responseHeaders?: Headers,\n    fallbackMsg?: MessageInfo<ChatMessage>,\n  ) => void;\n\n  /**\n   * @description Callback when the request is updated\n   */\n  onUpdate?: (\n    chunk: Output,\n    responseHeaders: Headers,\n    chatMessage?: MessageInfo<ChatMessage>,\n  ) => void;\n}\n\nexport interface XRequestOptions<\n  Input = AnyObject,\n  Output = SSEOutput,\n  ChatMessage extends SimpleType = any,\n> extends RequestInit {\n  /**\n   * @description Callbacks for the request\n   */\n  callbacks?: XRequestCallbacks<Output, ChatMessage>;\n  /**\n   * @description The parameters to be sent\n   */\n  params?: Input;\n  /**\n   * @description The custom headers to be sent\n   */\n  headers?: Record<string, string>;\n  /**\n   * @description The timeout for the request\n   */\n  timeout?: number;\n  /**\n   * @description The timeout for the stream mode request,when the stream mode request is timeout, the request will be aborted\n   */\n  streamTimeout?: number;\n  /**\n   * @description Custom fetch\n   */\n  fetch?: (\n    baseURL: Parameters<typeof fetch>[0],\n    options: XRequestOptions<Input, Output>,\n  ) => Promise<Response>;\n  /**\n   * @description Middlewares for the request and response\n   */\n  middlewares?: XFetchMiddlewares<Input, Output>;\n  /**\n   * @description Custom stream transformer, can use to adapt the stream data to the custom format\n   */\n  transformStream?:\n    | XStreamOptions<Output>['transformStream']\n    | ((baseURL: string, responseHeaders: Headers) => XStreamOptions<Output>['transformStream']);\n  /**\n   * @description Separator for stream data parsing\n   */\n  streamSeparator?: string;\n  /**\n   * @description Separator for different parts within the stream\n   */\n  partSeparator?: string;\n  /**\n   * @description Separator for key-value pairs in the stream data\n   */\n  kvSeparator?: string;\n  /**\n   * @description Whether to manually run the request\n   */\n  manual?: boolean;\n\n  /**\n   * @description The interval after the request is failed\n   */\n  retryInterval?: number;\n\n  /**\n   * @description Retry times limit, valid when retryInterval is set or onError returns a number\n   */\n  retryTimes?: number;\n}\n\nexport type XRequestGlobalOptions<Input, Output> = Pick<\n  XRequestOptions<Input, Output>,\n  'headers' | 'timeout' | 'streamTimeout' | 'middlewares' | 'fetch' | 'transformStream' | 'manual'\n>;\n\nexport type XRequestFunction<Input = AnyObject, Output = SSEOutput> = (\n  baseURL: string,\n  options?: XRequestOptions<Input, Output>,\n) => XRequestClass<Input, Output>;\n\n/**\n * @description Global options for the request\n */\nconst globalOptions: XRequestGlobalOptions<AnyObject, AnyObject> = {\n  manual: false,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n};\n\n/**\n * Set global options for the request\n * @param options XRequestGlobalOptions<Input, Output>\n */\nexport function setXRequestGlobalOptions<Input, Output>(\n  options: XRequestGlobalOptions<Input, Output>,\n) {\n  Object.assign(globalOptions, options);\n}\n\nconst LastEventId = 'Last-Event-ID';\n\nexport abstract class AbstractXRequestClass<Input, Output, ChatMessage extends SimpleType = any> {\n  baseURL!: string;\n  options!: XRequestOptions<Input, Output, ChatMessage>;\n\n  constructor(baseURL: string, options?: XRequestOptions<Input, Output, ChatMessage>) {\n    if (!baseURL || typeof baseURL !== 'string') throw new Error('The baseURL is not valid!');\n    this.baseURL = baseURL;\n    this.options = options || {};\n  }\n\n  abstract get asyncHandler(): Promise<any>;\n  abstract get isTimeout(): boolean;\n  abstract get isStreamTimeout(): boolean;\n  abstract get isRequesting(): boolean;\n  abstract get manual(): boolean;\n\n  abstract run(params?: Input): void;\n  abstract abort(): void;\n}\n\nexport class XRequestClass<\n  Input = AnyObject,\n  Output = SSEOutput,\n  ChatMessage extends SimpleType = any,\n> extends AbstractXRequestClass<Input, Output, ChatMessage> {\n  private _asyncHandler!: Promise<any>;\n\n  private timeoutHandler!: number;\n  private _isTimeout = false;\n  private streamTimeoutHandler!: number;\n  private _isStreamTimeout = false;\n  private abortController!: AbortController;\n  private _isRequesting = false;\n  private _manual = false;\n  private lastManualParams?: Partial<Input>;\n  private retryTimes = 0;\n  private retryTimer!: ReturnType<typeof setTimeout>;\n  private lastEventId = undefined;\n\n  public get asyncHandler() {\n    return this._asyncHandler;\n  }\n\n  public get isTimeout() {\n    return this._isTimeout;\n  }\n\n  private set isTimeout(value: boolean) {\n    this._isTimeout = value;\n  }\n\n  public get isStreamTimeout() {\n    return this._isStreamTimeout;\n  }\n\n  private set isStreamTimeout(value: boolean) {\n    this._isStreamTimeout = value;\n  }\n\n  public get isRequesting() {\n    return this._isRequesting;\n  }\n\n  public get manual() {\n    return this._manual;\n  }\n\n  constructor(baseURL: string, options?: XRequestOptions<Input, Output, ChatMessage>) {\n    super(baseURL, options);\n    this._manual = options?.manual || false;\n    if (!this.manual) {\n      this.init();\n    }\n  }\n\n  public run(params?: Input) {\n    if (this.manual) {\n      this.resetRetry();\n      this.lastManualParams = params;\n      this.init(params);\n      return true;\n    }\n    console.warn('The request is not manual, so it cannot be run!');\n    return false;\n  }\n\n  public abort() {\n    clearTimeout(this.timeoutHandler);\n    clearTimeout(this.streamTimeoutHandler);\n    this.abortController.abort();\n  }\n\n  private init(extraParams?: Partial<Input>, extraHeaders?: Record<string, string>) {\n    this.abortController = new AbortController();\n    const {\n      callbacks,\n      params,\n      headers = {},\n      transformStream,\n      fetch,\n      timeout,\n      streamTimeout,\n      middlewares,\n      streamSeparator,\n      partSeparator,\n      kvSeparator,\n      ...otherOptions\n    } = this.options;\n    const margeHeaders = Object.assign(\n      {},\n      globalOptions.headers || {},\n      headers,\n      extraHeaders || {},\n    );\n    const requestInit: XRequestOptions<Input, Output> = {\n      ...otherOptions,\n      method: 'POST',\n      body: JSON.stringify({\n        ...params,\n        ...(extraParams || {}),\n      }),\n      params: {\n        ...params,\n        ...extraParams,\n      } as Input,\n      headers: margeHeaders,\n      signal: this.abortController.signal,\n      middlewares,\n    };\n    if (timeout && timeout > 0) {\n      this.timeoutHandler = window.setTimeout(() => {\n        this.isTimeout = true;\n        this.finishRequest();\n        callbacks?.onError?.(new Error('TimeoutError'));\n      }, timeout);\n    }\n    this.startRequest();\n    // save and export a async handler to wait for the request to be finished\n    // though it is not necessary, but it is useful for some scenarios\n    this._asyncHandler = xFetch<Input, Output>(this.baseURL, {\n      fetch,\n      ...requestInit,\n    })\n      .then(async (response) => {\n        clearTimeout(this.timeoutHandler);\n\n        if (this.isTimeout) return;\n\n        if (transformStream) {\n          let transformer = transformStream as XStreamOptions<Output>['transformStream'];\n          if (typeof transformStream === 'function') {\n            transformer = transformStream(this.baseURL, response.headers);\n          }\n          await this.customResponseHandler<Output, ChatMessage>(\n            response,\n            callbacks,\n            transformer,\n            streamTimeout,\n            streamSeparator,\n            partSeparator,\n            kvSeparator,\n          );\n          return;\n        }\n        const contentType = response.headers.get('content-type') || '';\n        const mimeType = contentType.split(';')[0].trim();\n        switch (mimeType) {\n          /** SSE */\n          case 'text/event-stream':\n            await this.sseResponseHandler<Output, ChatMessage>(\n              response,\n              callbacks,\n              streamTimeout,\n              streamSeparator,\n              partSeparator,\n              kvSeparator,\n            );\n            break;\n          /** JSON */\n          case 'application/json':\n            await this.jsonResponseHandler<Output, ChatMessage>(response, callbacks);\n            break;\n          default:\n            throw new Error(`The response content-type: ${contentType} is not support!`);\n        }\n      })\n      .catch((error) => {\n        clearTimeout(this.timeoutHandler);\n        this.finishRequest();\n        // abort() throw a DOMException, so we need to check it\n        const err =\n          error instanceof Error || error instanceof DOMException\n            ? error\n            : new Error('Unknown error!');\n        // get retry interval from return of onError or options\n        const returnOfOnError = callbacks?.onError?.(err);\n        // ignore abort error\n        if (err.name !== 'AbortError') {\n          const retryInterval =\n            typeof returnOfOnError === 'number' ? returnOfOnError : this.options.retryInterval;\n          if (retryInterval && retryInterval > 0) {\n            // if retry times limit is set, check if the retry times is reached\n            if (\n              typeof this.options.retryTimes === 'number' &&\n              this.retryTimes >= this.options.retryTimes\n            ) {\n              return;\n            }\n            clearTimeout(this.retryTimer);\n            this.retryTimer = setTimeout(() => {\n              const extraHeaders: Record<string, string> = {};\n              if (typeof this.lastEventId !== 'undefined') {\n                // add Last-Event-ID header for retry\n                extraHeaders[LastEventId] = this.lastEventId;\n              }\n              this.init(this.lastManualParams, extraHeaders);\n            }, retryInterval);\n            this.retryTimes = this.retryTimes + 1;\n          }\n        }\n      });\n  }\n\n  private startRequest() {\n    this._isRequesting = true;\n  }\n\n  private finishRequest() {\n    this._isRequesting = false;\n  }\n\n  private customResponseHandler = async <Output = SSEOutput, ChatMessage extends SimpleType = any>(\n    response: Response,\n    callbacks?: XRequestCallbacks<Output, ChatMessage>,\n    transformStream?: XStreamOptions<Output>['transformStream'],\n    streamTimeout?: number | undefined,\n    streamSeparator?: string,\n    partSeparator?: string,\n    kvSeparator?: string,\n  ) => {\n    const stream = XStream<Output>({\n      readableStream: response.body!,\n      transformStream,\n      streamSeparator,\n      partSeparator,\n      kvSeparator,\n    });\n    await this.processStream<Output, ChatMessage>(stream, response, callbacks, streamTimeout);\n  };\n\n  private sseResponseHandler = async <Output = SSEOutput, ChatMessage extends SimpleType = string>(\n    response: Response,\n    callbacks?: XRequestCallbacks<Output, ChatMessage>,\n    streamTimeout?: number,\n    streamSeparator?: string,\n    partSeparator?: string,\n    kvSeparator?: string,\n  ) => {\n    const stream = XStream<Output>({\n      readableStream: response.body!,\n      streamSeparator,\n      partSeparator,\n      kvSeparator,\n    });\n    await this.processStream<Output, ChatMessage>(stream, response, callbacks, streamTimeout);\n  };\n\n  private async processStream<Output, ChatMessage extends SimpleType = string>(\n    stream: XReadableStream<Output>,\n    response: Response,\n    callbacks?: XRequestCallbacks<Output, ChatMessage>,\n    streamTimeout?: number,\n  ) {\n    const chunks: Output[] = [];\n    const iterator = stream[Symbol.asyncIterator]();\n    let result: IteratorResult<Output, any>;\n    do {\n      // if streamTimeout is set, start the stream timeout timer\n      // every time the stream is updated, reset the timer\n      if (streamTimeout) {\n        this.streamTimeoutHandler = window.setTimeout(() => {\n          this.isStreamTimeout = true;\n          this.finishRequest();\n          callbacks?.onError?.(new Error('StreamTimeoutError'), undefined, response.headers);\n        }, streamTimeout);\n      }\n\n      result = await iterator.next();\n      clearTimeout(this.streamTimeoutHandler);\n      if (this.isStreamTimeout) {\n        break;\n      }\n\n      if (result.value) {\n        chunks.push(result.value);\n        callbacks?.onUpdate?.(result.value, response.headers);\n        if (typeof result?.value?.id !== 'undefined') {\n          // cache Last-Event-ID for retry request\n          this.lastEventId = result.value.id;\n        }\n      }\n    } while (!result.done);\n    if (streamTimeout) {\n      clearTimeout(this.streamTimeoutHandler);\n      if (this.isStreamTimeout) {\n        this.finishRequest();\n        return;\n      }\n    }\n    this.finishRequest();\n    callbacks?.onSuccess?.(chunks, response.headers);\n  }\n\n  private jsonResponseHandler = async <\n    Output = JSONOutPut,\n    ChatMessage extends SimpleType = string,\n  >(\n    response: Response,\n    callbacks?: XRequestCallbacks<Output, ChatMessage>,\n  ) => {\n    const chunk: Output = await response.json();\n\n    if ((chunk as JSONOutPut)?.success === false) {\n      const error = new Error((chunk as JSONOutPut).message || 'System error');\n      error.name = (chunk as JSONOutPut).name || 'SystemError';\n      callbacks?.onError?.(error, chunk, response.headers);\n    } else {\n      callbacks?.onUpdate?.(chunk, response.headers);\n      this.finishRequest();\n      // keep type consistency with stream mode\n      callbacks?.onSuccess?.([chunk], response.headers);\n    }\n  };\n\n  private resetRetry() {\n    clearTimeout(this.retryTimer);\n    this.retryTimes = 0;\n    this.lastEventId = undefined;\n  }\n}\n\nfunction XRequest<Input = AnyObject, Output = SSEOutput, ChatMessage extends SimpleType = any>(\n  baseURL: string,\n  options?: XRequestOptions<Input, Output, ChatMessage>,\n): AbstractXRequestClass<Input, Output, ChatMessage> {\n  return new XRequestClass<Input, Output, ChatMessage>(baseURL, options);\n}\n\nexport default XRequest;\n"],"names":[],"mappings":"SIoBI,8BJDJ,IAAM,EAAqB,OAAO,sBAKlC,SAAS,EAA4C,CAAc,EACjE,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EAAO,OAAO,AACzB,CACA,IAAM,EAAmB,EAAQ,SAAS,CA+BpC,EAAiB,OAAO,SAAS,CAAC,cAAc,CAChD,EAAgC,aAAlB,OAAO,QAA0B,OAAO,WAAW,CAEvE,SAAS,EACP,CAAQ,CACR,CAAiB,CACjB,CAA2C,EAEvC,AAAC,EAAe,IAAI,CAAC,EAAK,IAC5B,OAAO,cAAc,CAAC,EAAK,EAAM,EACrC,CAEA,SAAS,EACP,CAAgC,CAChC,CAAY,EAEZ,IAAI,EAAS,CAAW,CAAC,EAAG,CAO5B,OANK,IAGH,EAAS,EAAmB,AAHjB,GAIX,CAAW,CAAC,EAAG,CAAG,GAEb,CACT,CAKA,SAAS,EAAmB,CAAY,EACtC,MAAO,CACL,QAAS,CAAC,EACV,WAAO,EACP,QAAQ,EACR,KACA,qBAAiB,EACjB,CAAC,EAAmB,CAAE,MACxB,CACF,CAKA,SAAS,EACP,CAAgB,CAChB,CAAoE,EAIpE,IAAK,IAAM,KAFX,EAAW,EAAS,aAAc,CAAE,MAAO,EAAK,GAC5C,GAAa,EAAW,EAAS,EAAa,CAAE,MAAO,QAAS,GAClD,EAAS,CACzB,IAAM,EAAO,CAAO,CAAC,EAAI,CACrB,MAAM,OAAO,CAAC,GAChB,EAAW,EADY,AACH,EAAK,CACvB,IAAK,CAAI,CAAC,EAAE,CACZ,IAAK,CAAI,CAAC,EAAE,CACZ,YAAY,CACd,GAEA,EAAW,EAAS,EAAK,CAAE,IAAK,EAAM,YAAY,CAAK,EAE3D,CACA,OAAO,IAAI,CAAC,EACd,CAmBA,EAAiB,CAAC,CAdlB,EAcqB,OAdZ,AAEP,CAAkC,CAClC,CAAwB,EAExB,IAAI,EAAS,IAAI,CAAC,CAAC,CACf,EAAU,IAAI,CAAC,CAAC,AACV,MAAM,CAAZ,IAEF,EAAU,CADV,EAAS,EAAqB,IAAI,CAAC,CAAC,CAAE,EAAA,EACrB,OAAA,AAAO,EAE1B,EAAO,eAAe,CAAG,EAAO,OAAO,CACvC,EAAI,EAAS,EACf,EAwDA,EAAiB,CAAC,CAjBlB,EAiBqB,OAjBZ,AAEP,CAA2B,CAC3B,CAAwB,UAExB,MAAI,EAAS,IAAI,CAAC,CAAC,CACf,EAAU,IAAI,CAAC,CAAC,AACV,MAAM,CAAZ,GAEF,GAAU,CADV,EAAS,EAAqB,IAAI,CAAC,CAAC,CAAE,EAAA,EACrB,OAAA,AAAO,EA7CE,EA+CP,EA/CuB,EA+Cf,AA/Ca,GACtC,EADwD,AACpC,CAAM,CAAC,EAAmB,IAGhD,EAAoB,CAAM,CAAC,EAAmB,CAAG,EAAE,CACnD,EAAO,OAAO,CAAG,EAAO,eAAe,CAAG,IAAI,MAAM,EAAS,CAC3D,IAAI,CAAM,CAAE,CAAI,EACd,GACE,EAAe,IAAI,CAAC,EAAQ,IACnB,YAAT,GACS,cACT,CADA,EAEA,OAAO,QAAQ,GAAG,CAAC,EAAQ,GAE7B,IAAK,IAAM,KAAO,EAAoB,CACpC,IAAM,EAAQ,QAAQ,GAAG,CAAC,EAAK,GAC/B,QAAc,IAAV,EAAqB,OAAO,CAClC,CAEF,EACA,QAAQ,CAAM,EACZ,IAAM,EAAO,QAAQ,OAAO,CAAC,GAC7B,IAAK,IAAM,KAAO,EAChB,IAAK,IAAM,KAAO,GADkB,KACV,OAAO,CAAC,GACpB,EAD0B,UAClC,CAAqB,EAAC,EAAK,QAAQ,CAAC,IAAM,EAAK,IAAI,CAAC,GAG5D,OAAO,CACT,CACF,IAoBoB,UAAlB,OAAO,GAAkC,MAAM,CAAjB,GAChC,CAAM,CAAC,EAAmB,CAAE,IAAI,CAAC,EAErC,EAcA,EAAiB,CAAC,CAXlB,EAWqB,OAXZ,AAEP,CAAU,CACV,CAAwB,EAExB,IAAI,EAAS,IAAI,CAAC,CAAC,AACT,MAAM,CAAZ,IACF,EAAS,EAAqB,IAAI,CAAC,CAAC,CAAE,EAAA,EAExC,EAAO,OAAO,CAAG,CACnB,EAcA,EAAiB,CAAC,CAXlB,EAWqB,OAXZ,AAEP,CAAc,CACd,CAAwB,EAExB,IAAI,EAAS,IAAI,CAAC,CAAC,AACT,MAAM,CAAZ,IACF,EAAS,EAAqB,IAAI,CAAC,CAAC,CAAE,EAAA,EAExC,EAAO,OAAO,CAAG,EAAO,eAAe,CAAG,CAC5C,EAUA,IAAM,EAA8B,OAAO,cAAc,CACrD,AAAC,GAAQ,OAAO,cAAc,CAAC,GAC/B,AAAC,GAAQ,EAAI,SAAS,CAGpB,EAAkB,CAAC,KAAM,EAAS,CAAC,GAAI,EAAS,EAAE,EAAG,EAAS,GAAU,CAS9E,SAAS,EACP,CAAY,CACZ,CAAsB,CACtB,CAA4B,EAE5B,IAAM,EAAsC,OAAO,MAAM,CAAC,MAC1D,IACE,IAAI,EAAU,EACd,CAAoB,UAAnB,OAAO,GAA2C,YAAnB,OAAO,CAAY,CAAU,EAC7D,CAAC,EAAgB,QAAQ,CAAC,GAC1B,EAAU,EAAS,GAEnB,IAAK,EADL,EACW,KAAO,OAAO,mBAAmB,CAAC,GAC3C,CAAO,CAAC,EAAI,CAAG,AAlCrB,CAiC2D,QAjCrC,AAAb,CAA8C,CAAE,CAAoB,EAC3E,MAAO,IAAM,CAAG,CAAC,EAAI,AACvB,EAgCkC,EAAK,GAWrC,OALI,AAAE,CAAD,EAAuB,YAAa,IACvC,EAAQ,CADsC,GAAG,CAC1C,EAAW,CAAG,IAAM,CAAA,EAG7B,EAAI,EAAI,GACD,CACT,CAEA,SAAS,EAAS,CAAsB,QACtC,AAAI,AAAe,YAAY,OAApB,EACF,SAAqB,GAAG,CAAW,EACxC,OAAO,EAAI,KAAK,CAAC,IAAI,CAAE,EACzB,EAEO,OAAO,MAAM,CAAC,KAEzB,CA+GA,SAAS,IACP,IAAI,EACA,EAOJ,MAAO,CACL,QANc,IAAI,QAAW,CAAC,EAAK,KACnC,EAAS,EACT,EAAU,CACZ,GAIE,QAAS,EACT,OAAQ,CACV,CACF,CAzGA,EAAiB,CAAC,CAlBlB,EAkBqB,OAlBZ,AAEP,CAAY,EAEZ,IAAM,EAAS,EAAiC,EAAI,IAAI,CAAC,CAAC,EAC1D,GAAI,EAAO,KAAK,CAAE,MAAM,EAAO,KAAK,CAGpC,GAAI,EAAO,eAAe,CAAE,OAAO,EAAO,eAAe,CAGzD,IAAM,EAAM,EAAO,OAAO,CAC1B,OAAQ,EAAO,eAAe,CAAG,EAC/B,EACA,EAAS,GACT,GAAQ,EAAY,UAAU,CAElC,EAYA,EAAiB,CAAC,CATlB,EASqB,OATZ,AAEP,CAAkB,EAKlB,OAAO,AAHQ,IAAI,CAAC,CAAC,CAAC,GAGR,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,EAChC,EAaA,EAAiB,CAAC,CANG,EAMA,UANnB,OAAO,QAEH,QACA,SAAS,EACP,MAAM,AAAI,MAAM,oCAClB,EAWN,EAAiB,CAAC,CARlB,EAQqB,OARZ,AAEP,CAAY,EAEZ,IAAM,EAAS,EAAiC,EAAI,IAAI,CAAC,CAAC,EAC1D,GAAI,EAAO,KAAK,CAAE,MAAM,EAAO,KAAK,CACpC,OAAO,EAAO,OAChB,AADuB,EAsCvB,EAAiB,CAAC,CA/BlB,EA+BqB,OA/BZ,AAAc,CAAqB,EAC1C,SAAS,EAAc,CAAY,EACjC,GAAI,EAAe,IAAI,CAAC,EAAK,GAC3B,EADgC,KACzB,CAAG,CAAC,EAAG,CAAC,MAAM,GAGvB,IAAM,EAAI,AAAI,MAAM,CAAC,oBAAoB,EAAE,EAAG,CAAC,CAAC,CAEhD,OADC,EAAU,IAAI,CAAG,mBACZ,CACR,CAoBA,OAlBA,EAAc,IAAI,CAAG,IACZ,OAAO,IAAI,CAAC,GAGrB,EAAc,OAAO,CAAG,AAAC,IACvB,GAAI,EAAe,IAAI,CAAC,EAAK,GAC3B,EADgC,KACzB,CAAG,CAAC,EAAG,CAAC,EAAE,GAGnB,IAAM,EAAI,AAAI,MAAM,CAAC,oBAAoB,EAAE,EAAG,CAAC,CAAC,CAEhD,OADC,EAAU,IAAI,CAAG,mBACZ,CACR,EAEA,EAAc,MAAM,CAAG,MAAO,GACrB,MAAO,EAAc,GAGvB,CACT,EA0CA,IAAM,EAAkB,OAAO,oBACzB,EAAmB,OAAO,qBAC1B,EAAiB,OAAO,mBAa9B,SAAS,EAAa,CAAkB,EAClC,GAAqB,GAA2B,CAAvC,EAAM,MAAM,GACvB,EAAM,MAAM,CAAA,EACZ,EAAM,OAAO,CAAC,AAAC,GAAO,EAAG,UAAU,IACnC,EAAM,OAAO,CAAE,AAAD,GAAS,EAAG,UAAU,GAAK,EAAG,UAAU,GAAK,KAE/D,CAyIA,EAAiB,CAAC,CAzFlB,EAyFqB,OAzFZ,AAEP,CAKS,CACT,CAAiB,EAEjB,IAAM,EAAS,IAAI,CAAC,CAAC,CACf,EAAgC,EAClC,OAAO,MAAM,CAAC,EAAE,CAAE,CAAE,MAAM,CAAA,EAAsB,QAChD,EAEE,EAA6B,IAAI,IAEjC,SAAE,CAAO,QAAE,CAAM,CAAE,QAAS,CAAU,CAAE,CAAG,IAE3C,EAA8B,OAAO,MAAM,CAAC,EAAY,CAC5D,CAAC,EAAiB,CAAE,EAAO,OAAO,CAClC,CAAC,EAAgB,CAAE,AAAC,IAClB,GAAS,EAAG,GACZ,EAAU,OAAO,CAAC,GAClB,EAAQ,KAAD,AAAS,CAAC,KAAO,EAC1B,CACF,GAEM,EAAiC,KACrC,IACS,EAET,IAAI,CAAM,EAEJ,IAAM,GACR,EAAO,CAAC,EAAiB,CADR,CACW,CAEhC,CACF,EAEA,OAAO,cAAc,CAAC,EAAQ,UAAW,GACzC,OAAO,cAAc,CAAC,EAAQ,kBAAmB,GA0CjD,EAxCA,GAwCK,MAxCI,AAAwB,CAAW,EAC1C,IAAM,EA/ED,AA+EwB,EA/EnB,GAAG,CAAC,AAAC,IAsHa,AArH5B,EA8EoB,CA9ER,OAAR,GAA+B,UAAf,OAAO,EAAkB,CAC3C,GA1DG,CA0DC,IAAiB,EAAM,OAAO,EAClC,GAnEF,AAAgB,AAQQ,CA2DlB,QAlEkB,UAAxB,OAAO,GACP,SAiEgB,CAjEN,EACmB,YAA7B,OAAO,EAAa,IAAI,CAgEF,CAClB,IAAM,EAAoB,OAAO,MAAM,CAAC,EAAE,CAAE,CAC1C,MAAM,CAAA,CACR,GAEM,EAAsB,CAC1B,CAAC,EAAiB,CAAE,CAAC,EACrB,CAAC,EAAgB,CAAE,AAAC,GAAoC,EAAG,EAC7D,EAaA,OAXA,EAAI,IAAI,CACN,AAAC,IACC,CAAG,CAAC,EAAiB,CAAG,EACxB,EAAa,EACf,EACA,AAAC,IACC,CAAG,CAAC,EAAe,CAAG,EACtB,EAAa,EACf,GAGK,CACT,CACF,CAEA,MAAO,CACL,CAAC,EAAiB,CAAE,EACpB,CAAC,EAAgB,CAAE,KAAO,CAC5B,CACF,GAiDQ,EAAY,IAChB,EAAY,GAAG,CAAC,AAAC,IACf,GAAI,CAAC,CAAC,EAAe,CAAE,MAAM,CAAC,CAAC,EAAe,CAC9C,OAAO,CAAC,CAAC,EACX,AAD4B,GAGxB,SAAE,CAAO,SAAE,CAAO,CAAE,CAAG,IAEvB,EAAmB,OAAO,MAAM,CAAC,IAAM,EAAQ,GAAY,CAC/D,WAAY,CACd,GAEA,SAAS,EAAQ,CAAa,EACxB,IAAM,GAAS,CAAC,EAAU,GAAG,CAAC,IAAI,CACpC,EAAU,GAAG,CAAC,GACV,GAAa,GAA6B,CAArC,EAAE,MAAM,GACf,EAAG,UAAU,GACb,EAAE,IAAI,CAAC,IAGb,CAIA,OAFA,EAAY,GAAG,CAAC,AAAC,GAAQ,CAAG,CAAC,EAAgB,CAAC,IAEvC,EAAG,UAAU,CAAG,EAAU,GACnC,EAEA,SAAS,AAAY,CAAS,EACxB,EACF,EAAQ,CAAO,AADR,CACS,EAAe,CAAG,GAElC,EAAQ,CAAO,CAAC,EAAiB,EAGnC,EAAa,EACf,GAII,GAAqB,IAA0B,CAAtC,EAAM,MAAM,GACvB,EAAM,MAAM,CAAA,CAAA,CAEhB,EAaA,IAAM,EAAc,SAAgC,AAAvB,CAAuC,EAClE,IAAM,EAAU,IAAI,IAAI,EAAU,OAC5B,EAA8B,CAAC,EACrC,IAAK,IAAM,KAAO,EAAS,CAAM,CAAC,EAAI,CAAI,CAAe,CAAC,EAAI,CAK9D,IAAK,IAAM,KAJX,EAAO,IAAI,CAAG,EACd,EAAO,QAAQ,CAAG,EAAS,OAAO,CAAC,SAAU,IAC7C,EAAO,MAAM,CAAG,EAAO,QAAQ,CAAG,GAClC,EAAO,QAAQ,CAAG,EAAO,MAAM,CAAG,CAAC,GAAG,IAAsB,EAC1C,EAChB,OAAO,cAAc,CAAC,IAAI,CAAE,EAAK,CAC/B,YAAY,EACZ,cAAc,EACd,MAAO,CAAM,CAAC,EAChB,AADoB,EAExB,EAQA,SAAS,EAAU,CAAY,CAAE,CAAoC,EACnE,MAAM,AAAI,MAAM,CAAC,WAAW,EAAE,EAAe,GAAA,CAAQ,CACvD,CARA,EAAY,SAAS,CAAG,IAAI,SAAS,CACrC,EAAiB,CAAC,CAAG,EAerB,EAAiB,CAAC,CAHlB,EAGqB,OAHA,AAAZ,CAA+B,EACtC,MAAM,AAAI,MAAM,4CAClB,ECvkBA,IAAM,EACJ,EAAQ,SAAS,CA0BnB,MAAK,GAKF,CALE,EAAA,GAAA,CAAA,EAKF,CAAA,EAAA,OAAA,CAAA,EAAA,CAAA,UAKA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SAMA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SAhBE,GAiCL,IAAM,EAAmC,OAAO,MAAM,CAAC,MACvD,EAAiB,CAAC,CAAG,EAiCrB,IAAM,EAAc,QAAQ,OAAO,MAAC,GAC9B,EAAgC,IAAI,QAyG1C,SAAS,EAAoB,CAAoC,EAC/D,MAAO,GAAG,AAAkB,EACzB,KAAK,CAAC,KACN,GAAG,CAAC,AAAC,GAAM,mBAAmB,IAC9B,IAAI,CAAC,MACV,AADoC,CAlGpC,AAkGiB,EAlGO,CAAC,CANzB,EAM4B,OANnB,AAEP,CAAkB,EAElB,OAAO,AAKT,SAAS,AACP,CAAsB,CACtB,CAAsB,CACtB,CAAkB,EAElB,IAAM,EAAW,EAAQ,eAAe,CAVjC,AAUkC,EAAY,EAAY,GAC7D,EAAQ,EAA8B,GAAG,CAAC,GAC9C,QAAc,IAAV,EAAqB,CACvB,IAAM,EAAU,EAA8B,GAAG,CAAC,IAAI,CACpD,EACA,EACA,GAEF,EAAQ,EAAS,IAAI,CAAC,GAAS,KAAK,CAAE,AAAD,IACnC,IAAI,EAMA,EAAa,CAAC,YAAY,EAAE,EAAA,CAAY,AAW5C,OAAM,AAAI,MACR,CAAC,qBAAqB,EAAE,EAAS,CAAC,EAAE,EAAA,EAClC,EAAQ,CAAC,EAAE,EAAE,EAAA,CAAO,CAAG,GAAA,CACvB,CACF,EACI,CACE,MAAO,CACT,OACA,EAER,GACA,EAA8B,GAAG,CAAC,EAAU,EAC9C,CAEA,OAAO,CACT,EAnDS,EAA0C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAE,EAC9D,EAwEA,EAAwB,CAAC,CAPzB,EAO4B,OAPnB,AAEP,CAAgB,EAEhB,IAAM,EAAW,IAAI,CAAC,CAAC,CAAC,GACxB,OAAO,GAAU,SAAW,CAC9B,EAUA,EAAwB,CAAC,CAHzB,EAG4B,OAHnB,AAAoB,CAAmB,EAC9C,MAAO,CAAC,MAAM,EAAE,GAAc,GAAA,CAAI,AACpC,EAkEA,IAAM,EAAa,4BCnRb,EAAmC,CAAC,CAC1C,GAAiB,CAAC,CAAG,EA4BrB,IAAM,EAEF,CAAC,EAAI,KACP,IAAM,EAAS,CAAW,CAAC,EAAG,QAE9B,AAAI,GAIG,EAAkB,EAAI,CAJjB,CAI4B,MAAM,CAAE,EAAa,EAAE,CACjE,EAEA,SAAS,EACP,CAAY,CACZ,CAAsB,CACtB,CAAsB,EAEtB,IAAM,EAAgB,CAAe,CAAC,EAAG,CACZ,YAAzB,AAAqC,OAA9B,GAIT,ADwCJ,SAAS,AACP,CAAkB,CAClB,CAAsB,CACtB,CAAsB,EAEtB,IAAI,EACJ,OAAQ,GACN,KAAA,EACE,EAAsB,CAAC,4BAA4B,EAAE,EAAA,CAAY,CACjE,KACF,MAAA,EACE,EAAsB,CAAC,oCAAoC,EAAE,EAAA,CAAY,CACzE,KACF,MAAA,EACE,EAAsB,2BACtB,KACF,SACE,EACE,EACA,AAAC,GAAe,CAAC,qBAAqB,EAAE,EAAA,CAAY,CAE1D,CACA,MAAM,AAAI,MACR,CAAC,OAAO,EAAE,EAAS,kBAAkB,EAAE,EAAoB,uFAAuF,CAAC,CAEvJ,ECjEwB,EAAI,EAAY,GAGtC,IAAM,EAAiB,EAAmB,GAE1C,CAAW,CAAC,EAAG,CAAG,EAGlB,GAAI,CACF,IAAM,EAAU,IAAK,EAA8C,GACnE,EAAc,EAChB,CAAE,MAAO,EAAO,CAEd,MADA,EAAO,KAAK,CAAG,EACT,CACR,CAQA,OANA,EAAO,MAAM,EAAG,EACZ,EAAO,eAAe,EAAI,EAAO,OAAO,GAAK,EAAO,eAAe,EAAE,AAEvE,EAAW,EAAO,OAAO,CAAE,EAAO,eAAe,EAG5C,CACT,CAGA,SAAS,EAAc,CACrB,EACA,EACA,EACkB,EAClB,IAAM,EAAY,AD4JpB,SAAS,AACP,CAAsE,EAEtE,GAA2B,UAAU,AAAjC,OAAO,EACT,OAAO,EAMT,IAAM,EAAM,mBAAmB,AAH7B,CAAqC,oBAA9B,0BACH,0BAA0B,GAAG,GAC7B,EAAY,YAAY,CAAC,MAAA,EACS,OAAO,CAAC,UAAW,KACvD,EAAO,EAAI,UAAU,CAAC,IACtB,EAAI,KAAK,CAAC,GACV,EAIJ,OAHI,EAAK,EAFqB,MAAM,EAEjB,CAAC,MAAM,CACxB,EAAO,EAAK,KAAK,CAAC,EAAA,EAEb,CACT,EC9KsC,GACpC,IAAK,GAAM,CAAC,EAAU,EAAc,GAAI,OAAO,OAAO,CAAC,ID+KzD,AC9KI,SD8KK,AACP,CAAkB,AChLoD,CDiLtE,CAAgD,EAEhD,GAAI,CAAC,CAAe,CAAC,EAAS,CAC5B,CAD8B,EAC1B,MAAM,OAAO,CAAC,GAAgB,CAChC,GAAI,CAAC,EAAiB,EAAS,CAAG,EAElC,IAAK,IAAM,KADX,CAAe,CAAC,EAAS,CAAG,EACA,GAC1B,CAAe,CAAC,EAAc,CAAG,CAErC,AAHwC,MAItC,CAAe,AADV,CACW,EAAS,CAAG,CAGlC,EC7LoC,EAAU,GAG5C,OAAO,EAAQ,aAAa,CAAC,EAAW,EAC1C,CC/DA,SAAS,EACP,CAAY,CACZ,CAAgB,CAChB,GAAe,CAAK,EAEpB,IAAI,EACJ,GAAI,CACF,EAAM,GACR,CAAE,MAAO,EAAK,CAKZ,MAAM,AAAI,MAAM,CAAC,+BAA+B,EAAE,EAAG,EAAE,EAAE,EAAA,CAAK,CAChE,OAEA,AAAI,CAAC,GAAO,EAAI,UAAU,CACjB,CADmB,CAIrB,EAAW,EAAK,EAAS,IAAM,EACxC,CAvBA,EAAiB,CAAC,CAlBlB,EAkBqB,aAlBN,AAAe,CAAuB,EACnD,IAAI,EACJ,GAAI,CACF,EAAM,MAAM,MAAM,CAAC,EACrB,CAAE,MAAO,EAAK,CAKZ,MAAM,AAAI,MAAM,CAAC,+BAA+B,EAAE,EAAG,EAAE,EAAE,EAAA,CAAK,CAChE,QAEA,AAAI,GAAO,EAAI,UAAU,EAAI,EAAI,OAAO,EAAI,YAAa,EAAI,OAAO,CAC3D,CAD6D,CAClD,EAAI,OAAO,CAAE,EAAS,IAAM,GAGzC,CACT,EA0BA,EAAgB,OAAO,CAAG,CACxB,EACA,IAIO,QAAQ,OAAO,CAAC,EAAI,GAE7B,EAAiB,CAAC,CAAG,EClCrB,IAAM,EAA+C,IAAI,IAyCvD,SAAS,EAAoB,CAAkB,EAC7C,IAAI,EAAW,EAAe,GAAG,CAAC,GAClC,GAAI,CAAC,EAAU,CACb,IAAI,EACA,EAKJ,EAAW,CACT,UAAU,EACV,gBAAgB,EAChB,QAPc,IAAI,QAAc,CAAC,EAAc,KAC/C,EAAU,EACV,EAAS,CACX,GAKE,QAAS,KACP,EAAU,QAAQ,CAAG,GACrB,GACF,EACA,OAAQ,CACV,EACA,EAAe,GAAG,CAAC,EAAU,EAC/B,CACA,OAAO,CACT,CA5DA,EAAU,CACR,cAAc,CAAS,CAAE,CAAM,EAM7B,GAHiB,AACjB,EAHiB,EAAoB,IAG5B,OAAO,GAEZ,AAAU,EAHuB,IAGjB,GAIpB,IAAK,IAAM,KAAkB,EAAO,WAAW,CAK7C,AAL+C,EAEzB,EJ6UA,UAArB,CAAgC,KI1Ub,CJ0UZ,CI7UkC,CADN,EJ8US,EAAU,IAAI,GIvU7D,GAAI,EAAO,gBAAgB,CAAC,MAAM,CAAG,EACnC,CADsC,GACjC,IAAM,KAAY,EAAO,gBAAgB,CAAE,CAC9C,AFtCV,SAAS,AACP,CAAoB,CACpB,CAAkB,EAElB,IAAM,EAAS,CAAW,CAAC,EAAS,CACpC,GAAI,EAAQ,CACV,GAAI,EAAO,KAAK,CACd,CADgB,KACV,EAAO,KAAK,CAEpB,MACF,CADS,AAGF,EAAkB,EAAU,EAAW,OAAO,CAAE,EACzD,EEyBwC,EAAW,GAG/C,kBAMA,CACE,EACA,EACA,IAEO,CA+BX,CAnC0B,EACA,AACJ,MAiCb,AACP,CAAsB,CACtB,CAAuB,CACvB,CAAkB,EAElB,IAAM,EAAW,EAAoB,GACrC,GAAI,EAAS,cAAc,CACzB,CAD2B,MACpB,EAAS,OAAO,CAGzB,GAAI,IAAe,EAAW,OAAO,CASnC,CATqC,MAGrC,EAAS,cAAc,EAAG,EAMnB,EAAS,OAAO,CAGzB,GAAI,AAAyB,YAAY,OAA9B,cAET,IAAI,MAAK,GACP,KAAK,GADa,sBACY,CAAE,IAAI,CAAC,GACrC,cAAc,0BAA4B,QAE1C,MAAM,AAAI,MACR,CAAC,mCAAmC,EAAE,EAAS,UAAU,CAAC,MAGzD,CAEL,IAAM,EAAkB,UAAU,GAElC,GHyJG,CGzJC,CHyJU,IAAI,CAAC,AGzJV,GAAW,CAClB,IAAM,EAAkB,SAAS,gBAAgB,CAC/C,CAAC,YAAY,EAAE,EAAS,gBAAgB,EAAE,EAAS,gBAAgB,EAAE,EAAgB,gBAAgB,EAAE,EAAgB,GAAG,CAAC,EAE7H,GAAI,EAAgB,MAAM,CAAG,EAG3B,CAH8B,GAGzB,IAAM,KAAU,MAAM,IAAI,CAAC,GAC9B,EAAO,YADyC,IACzB,CAAC,QAAS,KAC/B,EAAS,MAAM,EACjB,OAEG,CACL,IAAM,EAAS,SAAS,aAAa,CAAC,UACtC,EAAO,GAAG,CAAG,EAIb,EAAO,OAAO,CAAG,KACf,EAAS,MAAM,EACjB,EAEA,SAAS,IAAI,CAAC,WAAW,CAAC,EAC5B,CACF,MACE,CADK,KACK,AAAJ,MAAU,CAAC,mCAAmC,EAAE,EAAA,CAAU,CAEpE,CAGA,OADA,EAAS,cAAc,EAAG,EACnB,EAAS,OAAO,CACzB,EAlGuB,EAAY,EAAY,EAE/C,iiBCxDW,IAA4b,EAAxb,EAAE,OAAO,GAAG,CAAC,iBAAiB,EAAE,OAAO,GAAG,CAAC,gBAAgB,EAAE,OAAO,GAAG,CAAC,kBAAkB,EAAE,OAAO,GAAG,CAAC,qBAAqB,EAAE,OAAO,GAAG,CAAC,kBAAkB,EAAE,OAAO,GAAG,CAAC,kBAAkB,EAAE,OAAO,GAAG,CAAC,iBAAiB,EAAE,OAAO,GAAG,CAAC,wBAAwB,EAAE,OAAO,GAAG,CAAC,qBAAqB,EAAE,OAAO,GAAG,CAAC,kBAAkB,EAAE,OAAO,GAAG,CAAC,uBAAuB,EAAE,OAAO,GAAG,CAAC,cAAc,EAAE,OAAO,GAAG,CAAC,cAAc,EAAE,OAAO,GAAG,CAAC,mBACtb,SAAS,EAAE,CAAC,EAAE,GAAG,UAAW,OAAO,GAAG,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE,QAAQ,CAAC,OAAO,GAAG,KAAK,EAAE,OAAO,EAAE,EAAE,IAAI,EAAC,AAAG,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,CAAE,SAAQ,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAI,AAAH,KAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,CAAE,SAAQ,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,CADkM,EAAE,OAAO,GAAG,CAAC,0BAC9M,EAAQ,eAAe,CAAC,EAAE,EAAQ,eAAe,CAAC,EAAE,EAAQ,OAAO,CAAC,EAAE,EAAQ,UAAU,CAAC,EAAE,EAAQ,QAAQ,CAAC,EAAE,EAAQ,IAAI,CAAC,EAAE,EAAQ,IAAI,CAAC,EAAE,EAAQ,MAAM,CAAC,EAAE,EAAQ,QAAQ,CAAC,EAAE,EAAQ,UAAU,CAAC,EAAE,EAAQ,QAAQ,CAAC,EAChe,EAAQ,YAAY,CAAC,EAAE,EAAQ,WAAW,CAAC,WAAW,MAAM,CAAC,CAAC,EAAE,EAAQ,gBAAgB,CAAC,WAAW,MAAM,CAAC,CAAC,EAAE,EAAQ,iBAAiB,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,iBAAiB,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,SAAS,CAAC,SAAS,CAAC,EAAE,MAAM,UAAW,OAAO,GAAG,OAAO,GAAG,EAAE,QAAQ,GAAG,CAAC,EAAE,EAAQ,YAAY,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,UAAU,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,MAAM,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,MAAM,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EACve,EAAQ,QAAQ,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,UAAU,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,YAAY,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,UAAU,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAQ,cAAc,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,EAClP,EAAQ,kBAAkB,CAAC,SAAS,CAAC,EAAE,MAAM,UAAW,OAAO,GAAG,YAAa,OAAO,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,UAAW,OAAO,GAAG,OAAO,IAAI,CAAD,CAAG,QAAQ,GAAG,GAAG,EAAE,QAAQ,GAAG,GAAG,EAAE,QAAQ,GAAG,GAAG,EAAE,QAAQ,GAAG,GAAG,EAAE,QAAQ,GAAG,GAAG,EAAE,QAAQ,GAAG,GAAG,KAAK,IAAI,EAAE,WAAA,AAAW,GAAK,CAAH,AAAI,CAAH,AAAI,EAAE,EAAQ,MAAM,CAAC,6BCV/S,EAAO,OAAO,CAAA,EAAA,CAAA,CAAA,oECcD,OAAe,EACpB,QAA6D,CAC7D,cAAqC,CACrC,kBAA4D,AAEpE,KAAW,SAAU,CACnB,OAAO,IAAI,CAAC,QAAQ,AACtB,CAEA,YAAY,CAAsD,CAAE,CAClE,MAAM,EAAoC,YAA1B,OAAO,EAAO,OAAO,CAAkB,EAAO,OAAO,GAAK,EAAO,OAAO,CACxF,GAAI,CAAC,EAAQ,MAAM,CACjB,CADmB,KACb,AAAI,MAAM,0BAElB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,kBAAkB,CAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,SACnD,CAwBA,aAA6B,CAC3B,OAAO,IAAI,EAAE,gBACf,CAEA,kBAAkB,CAAgC,CAAE,CAClD,IAAI,CAAC,cAAc,CAAG,CACxB,CAEA,cAAc,UACZ,CAAQ,WACR,CAAS,SACT,CAAO,CAKR,CAAE,CACD,IAAM,EAAmB,IAAI,CAAC,kBAAkB,EAAE,SAC5C,EAAoB,IAAI,CAAC,kBAAkB,EAAE,UAC7C,EAAkB,IAAI,CAAC,kBAAkB,EAAE,QACjD,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAG,CAChC,SAAU,CAAC,EAAc,KACvB,IAAM,EAAM,EAAS,EAAM,GACvB,GAAkB,EAAiB,EAAM,EAAiB,EAChE,EACA,UAAW,CAAC,EAAgB,KAC1B,IAAM,EAAM,EAAU,EAAM,GACxB,GAAmB,EAAkB,EAAM,EAAiB,EAClE,EACA,QAAS,CAAC,EAAO,EAAW,KAC1B,IAAM,EAAc,EAAQ,EAAO,GAC/B,GAAiB,EAAgB,EAAO,EAAW,EAAiB,EAC1E,CACF,CACF,CACF,CCjFe,MAAM,UAIX,EACR,gBACE,CAA6B,CAC7B,CAAoD,CAC7C,CACP,MAAO,CACL,GAAI,GAAS,QAAU,CAAC,CAAC,CACzB,GAAG,CAAa,CAChB,SAAU,IAAI,CAAC,WAAW,EAC5B,CACF,CAEA,sBAAsB,CAA6B,CAAiB,CAClE,OAAQ,GAAe,UAAY,EACrC,AADuC,CAGvC,iBAAiB,CAA2C,CAAe,CACzE,GAAM,eAAE,CAAa,OAAE,CAAK,iBAAE,CAAe,CAAE,CAAG,EAC9C,EAAiB,GACjB,EAAe,GACf,EAAO,YACX,GAAI,CACF,IAAI,EACA,EAAgB,GAAG,CAAC,iBAAiB,SAAS,qBAC5C,CADkE,EACzD,EAAM,IAAI,EAAE,SAAW,UAAU,CAC5C,EAAU,KAAK,KAAK,CAAC,EAAM,KAAI,EAGjC,EAAU,EAER,GACF,GAAS,GADE,MACO,QAAS,AAAD,IACpB,GAAQ,OAAO,AACjB,EAAe,EAAO,KAAK,CAAC,iBAAiB,EAAI,GACjD,GAAkB,EAAO,KAAK,CAAC,OAAO,EAAI,GAC1C,EAAO,EAAO,KAAK,CAAC,IAAI,EACf,GAAQ,SAAS,CAC1B,EAAe,EAAO,OAAO,CAAC,iBAAiB,EAAI,GACnD,GAAkB,EAAO,OAAO,CAAC,OAAO,EAAI,GAC5C,EAAO,EAAO,OAAO,CAAC,IAAI,CAE9B,EAEJ,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,yBAA0B,EAC1C,CACA,IAAI,EAAU,GACV,EACgC,UAAlC,OAAO,GAAe,QAClB,GAAe,QACf,GAAe,QAAQ,MAAQ,GAgBrC,MAfI,CAAC,GAAwB,EAE3B,EAAU,CAAC,SAF8B;AAE9B;AAAA;AAAA;AAAe,EAAE,GAAc,UAAU,WAAY,IAAA,CAAK,CAErE,EAAqB,QAAQ,CAAC,YAC9B,CAAC,EAAqB,QAAQ,CAAC,aAC/B,GAEA,EAAuB,EAAqB,OAAO,CAAC,CADpD,SAC+D,yBAE/D,EAAU,CAAA,EAAG,GAAsB,UAAU,eAAgB,IAAI;AAAA;AAAA;AAAA;AAAgB,EAAE,EAAA,CAAgB,EAEnG,EAAU,CAAA,EAAG,GAAwB,GAAA,EAAK,EAAA,EAAe,EAAA,CAAgB,CAGpE,SACL,EACA,KAAM,GAAQ,WAChB,CACF,CACF,CClFe,MAAM,UAIX,EACR,gBACE,CAA2C,CAC3C,CAAoD,CAC7C,CACP,GAAI,AAAyB,UAAU,OAA5B,EACT,MAAM,AAAI,MAAM,mCAElB,MAAO,CACL,GAAI,GAAS,QAAU,CAAC,CAAC,CACzB,GAAI,GAAiB,CAAC,CAAC,AACzB,CACF,CAEA,sBAAsB,CAA6B,CAAe,CAChE,OAAO,CACT,CAEA,iBAAiB,CAA2C,CAAe,CACzE,GAAM,OAAE,CAAK,QAAE,CAAM,eAAE,CAAa,CAAE,CAAG,EAEzC,GAAI,EACF,KADS,EACF,EAGT,GAAI,MAAM,OAAO,CAAC,GAAS,CACzB,IAAM,EAAQ,GAAQ,OAAS,EAAI,GAAQ,CAAC,GAAQ,OAAS,EAAE,MAAG,EAClE,OAAO,GAAiC,CAC1C,CAEA,OAAO,CACT,CACF,CC7Be,CDwBc,KCxBR,UAIX,EACR,gBACE,CAA6B,CAC7B,CAAoD,CAC7C,CACP,MAAO,CACL,GAAI,GAAS,QAAU,CAAC,CAAC,CACzB,GAAG,CAAa,CAChB,SAAU,IAAI,CAAC,WAAW,EAC5B,CACF,CAEA,sBAAsB,CAA6B,CAAiB,CAClE,OAAQ,GAAe,UAAY,EAAE,AACvC,CAEA,iBAAiB,CAA2C,CAAe,CACzE,GAAM,eAAE,CAAa,OAAE,CAAK,CAAE,iBAAe,CAAE,CAAG,EAC9C,EAAiB,GACjB,EAAO,YACX,GAAI,CACF,IAAI,EACA,EAAgB,GAAG,CAAC,iBAAiB,SAAS,qBAC5C,CADkE,EACzD,EAAM,IAAI,EAAE,SAAW,UAAU,CAC5C,EAAU,KAAK,KAAK,CAAC,EAAM,KAAI,EAGjC,EAAU,EAER,GACF,GAAS,GADE,MACO,QAAQ,AAAC,IACrB,GAAQ,OAAO,AACjB,GAAkB,EAAO,KAAK,CAAC,OAAO,EAAI,GAC1C,EAAO,EAAO,KAAK,CAAC,IAAI,EAAI,aACnB,GAAQ,SAAS,CAC1B,GAAkB,EAAO,OAAO,CAAC,OAAO,EAAI,GAC5C,EAAO,EAAO,OAAO,CAAC,IAAI,EAAI,YAElC,EAEJ,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,yBAA0B,EAC1C,CAIA,MAAO,CACL,QAHc,CAAA,EAAG,GAAe,SAAW,GAAA,EAAK,GAAkB,GAAA,CAAI,MAItE,CACF,CACF,CACF,sIChEA,MAAA,EAAA,EAAA,CAAA,CAAA,OACA,SAAS,AAAS,CAAQ,EACxB,IAAM,EAAQ,EAAA,MAAY,CAAC,GAG3B,CAEa,MAJb,AAEO,EAFD,OAAO,CAAG,EACD,EAAA,WAAiB,CAAC,CAAC,GAAG,IAAS,EAAM,OAAO,MAAM,GAAO,EAAE,CAE5E,CEFgC,ADLpB,CAAkB,oBAAX,QAA0B,OAAO,ACKe,QDLP,EAAI,OAAO,QAAQ,CAAC,aAAa,CCKZ,EAAA,eAAqB,CAAG,EAAA,SAAe,CILxH,EAAA,CAAA,CAAA,IED8B,OAAO,GAAG,CAAC,iBACX,OAAO,GAAG,CAAC,8BACb,OAAO,GAAG,CAAC,kBFEb,AAAO,EAAA,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CKHtD,IAAI,EAAS,CAAC,EACR,EAAgB,EAAE,CAqBjB,SAAS,EAAQ,CAAK,CAAE,CAAO,EAOtC,CAGO,SAAS,EAAK,CAAK,CAAE,CAAO,EAOnC,CAIO,SAAS,EAAK,CAAM,CAAE,CAAK,CAAE,CAAO,EACpC,GAAU,CAAM,CAAC,EAAQ,EAAhB,AAAkB,CAC9B,GAAO,EAAO,GACd,CAAM,CAAC,EAAQ,EAAG,EAEtB,CAGO,SAAS,EAAY,CAAK,CAAE,CAAO,EACxC,EAAK,EAAS,EAAO,EACvB,CAMA,EAAY,UAAU,CApDI,EAoDD,EAnDvB,EAAc,IAAI,CAAC,EACrB,EAmDA,EAAY,WAAW,CApBhB,EAoBmB,OApBV,EACd,EAAS,CAAC,CACZ,EAmBA,EAAY,QAAQ,CALb,EAKgB,OALE,AAAT,CAAc,CAAE,CAAO,EACrC,EAAK,EAAM,EAAO,EACpB,EGvDO,IAAM,EAA0B,CACrC,oBAAqB,IAAI,IACzB,IAAK,AAAC,GACG,EAAwB,mBAAmB,CAAC,GAAG,CAAC,GAEzD,IAAK,CAAC,EAAsB,KAC1B,EAAwB,mBAAmB,CAAC,GAAG,CAAC,EAAK,EACvD,EACA,OAAQ,AAAC,IACP,EAAwB,mBAAmB,CAAC,MAAM,CAAC,EACrD,EACA,YAAa,AAAC,IACZ,IAAM,EAAQ,EAAwB,mBAAmB,CAAC,GAAG,CAAC,GAC9D,OAAO,GAAO,aAChB,CACF,CAEO,OAAM,EACH,UAA4B,EAAE,AAAC,CAC/B,eAA6C,CAC7C,eAGJ,CACF,SAAU,EAAE,CACZ,6BAA6B,CAC/B,CAAE,CAEM,cAAsD,IAAK,CAC3D,aAAc,CAAM,CACX,iBAA2B,EAAG,CAEvC,aAAc,CAAM,CAEpB,eAAgB,CACtB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,AAAC,IACtB,GACF,EACF,CAEQ,wBAAyB,CAC1B,IAAI,CAAC,aAAa,CAcrB,CAduB,GAcnB,CAAC,WAAW,EAAG,GAZnB,IAAI,CAAC,aAAa,GAClB,IAAI,CAAC,WAAW,EAAG,EAEnB,IAAI,CAAC,aAAa,CAAG,WAAW,KAC9B,IAAI,CAAC,aAAa,CAAG,KAEjB,IAAI,CAAC,WAAW,EAAE,CACpB,IAAI,CAAC,aAAa,GAClB,IAAI,CAAC,WAAW,CAAG,GAEvB,EAAG,IAAI,CAAC,gBAAgB,EAI5B,CAEA,YAAY,CAAmC,CAAE,CAAiC,CAAE,CAElF,IAAI,CAAC,kBAAkB,CAAC,EAAiB,AAAC,IACxC,IAAI,CAAC,iBAAiB,CAAC,8BAA+B,GACtD,IAAI,CAAC,aAAa,EACpB,GAGI,IACF,IAAI,CAAC,QADc,OACC,CAAG,EACvB,EAAwB,GAAG,CAAC,IAAI,CAAC,eAAe,CAAE,IAAI,EAE1D,CAEA,MAAc,mBACZ,CAAmC,CACnC,CAAoE,CACpE,CACA,GAAI,CACF,GAA6B,GAC7B,IAAM,EAAW,MAAM,GAGnB,CAAC,IAAI,CAAC,WAAW,EAAE,AACrB,IAAI,CAAC,mBAAmB,CAAC,GAAU,EAEvC,CAAE,MAAO,EAAO,CAEd,QAAQ,IAAI,CAAC,iCAAkC,GAC3C,AAAC,IAAI,CAAC,WAAW,EAAE,AACrB,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAE,GAEjC,QAAU,CACR,GAA6B,EAC/B,CACF,CACQ,kBAAoB,CAC1B,EACA,KAEA,IAAI,CAAC,cAAc,CAAG,CACpB,GAAG,IAAI,CAAC,cAAc,CACtB,CAAC,EAAI,CAAE,CACT,CACF,CAAE,CACM,oBAAsB,CAAC,EAAqC,GAAW,CAAI,IACjF,IAAI,EAaJ,OAXE,EADsB,YAApB,AAAgC,OAAzB,EACF,EAAS,IAAI,CAAC,cAAc,CAAC,QAAQ,EAErC,EAET,IAAI,CAAC,iBAAiB,CAAC,WAAY,GAE/B,EACF,IAAI,CAAC,GADO,mBACe,GAE3B,IAAI,CAAC,aAAa,IAEb,CACT,CAAE,CAEF,YAAc,AAAC,GACN,IAAI,CAAC,mBAAmB,CAAC,GAAU,EAC1C,CAEF,YAAc,IACL,IAAI,CAAC,cAAc,CAAC,QAAQ,AACnC,AAEF,YAAa,AAAC,GACL,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,AAAC,GAAS,EAAK,EAAE,GAAK,EACrD,CAEF,WAAa,AAAC,GAEZ,CADc,GACV,CADc,AACb,CADc,MACP,IADiB,CAAC,EAAQ,EAAE,IAEtC,IAAI,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAE,EAAQ,GACpD,EAGT,CAEF,WAAa,CAAC,EAAqB,KACjC,IAAM,EAAgB,IAAI,CAAC,UAAU,CAAC,GACtC,GAAI,EAAe,CACjB,IAAM,EAAkC,YAAnB,OAAO,EAAyB,EAAQ,GAAiB,EAG9E,OAFA,OAAO,MAAM,CAAC,EAAe,GAC7B,IAAI,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,GAC3C,CACT,CACA,MAAO,EACT,CAAE,CAEF,cAAgB,AAAC,IACf,IAAM,EAAQ,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC,AAAC,GAAS,EAAK,EAAE,GAAK,UACjE,AAAc,CAAC,GAAG,CAAd,IACF,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAO,GAC3C,IAAI,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC,WAAW,GAAG,GACjC,EAGX,CAAE,CAEF,YAAc,IACL,IAAI,CAAC,cAAc,AAC1B,CAEF,UAAY,AAAC,IACX,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GACb,KACL,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,AAAC,GAAa,IAAa,GAGpC,GAAG,CAA7B,IAAI,CAAC,SAAS,CAAC,MAAM,GACnB,IAAI,CAAC,aAAa,EAAE,CACtB,aAAa,IAAI,CAAC,aAAa,EAC/B,IAAI,CAAC,aAAa,CAAG,MAEvB,IAAI,CAAC,WAAW,EAAG,EAEvB,EACA,CAMF,QAAU,KACR,IAAI,CAAC,WAAW,EAAG,EACf,IAAI,CAAC,aAAa,EAAE,CACtB,aAAa,IAAI,CAAC,aAAa,EAC/B,IAAI,CAAC,aAAa,CAAG,MAEvB,IAAI,CAAC,WAAW,CAAG,GACnB,IAAI,CAAC,SAAS,CAAG,EACnB,AADqB,CACnB,AACJ,CC7LA,IAAK,IAAA,EAAA,GAAA,CAAA,+GAAA,GAwEL,IAAM,EAAkB,IAAI,IAGb,SAAS,EAKtB,CAA8D,EAC9D,GAAM,iBACJ,CAAe,iBACf,CAAe,oBACf,CAAkB,QAClB,CAAM,UACN,CAAQ,CACR,gBAAiB,CAAuB,CACzC,CAAG,EAGE,EAAQ,EAAA,OAAK,CAAC,MAAM,CAAC,GACrB,EACJ,EAAA,OAAK,CAAC,MAAM,MAAoD,GAC5D,CAAC,EAAc,EAAgB,CAAG,CAAA,EAAA,EAAA,QAAA,AAAQ,GAAU,GAEpD,CAAC,EAAiB,EAAmB,CAAG,CAAA,EAAA,EAAA,QAAA,AAAQ,EACpD,GAxBkC,OAAO,iBAwBd,GAG7B,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,KACJ,GACF,EAAmB,EAEvB,EAAG,CAAC,EAAwB,EAE5B,GAAM,CACJ,OAN6B,GAMrB,6BACR,CAA2B,eAC3B,CAAa,CACb,aAAW,aACX,CAAW,YACX,CAAU,CACX,CAAG,AD8EC,SAAS,AACd,CAAgC,CAChC,CAAgC,EAEhC,IAAM,EAAc,IACd,AAAJ,EAA4B,GAAG,CAAC,GACvB,EAAwB,GAAG,CAAC,GAGvB,IAAI,EAJgC,AAIX,EAAc,GAGjD,CAAC,EAAO,EAAS,CAAG,CAAA,EAAA,EAAA,QAAA,AAAQ,EAAC,GAEnC,CAAA,EAAA,EAAA,SAAS,AAAT,EAAU,KACR,EAAS,IACX,EAAG,CAAC,EAAgB,EAEpB,GAAM,CAAE,UAAQ,6BAAE,CAA2B,CAAE,CAAG,CAAA,EAAA,EAAA,oBAAoB,AAApB,EAChD,EAAM,SAAS,CACf,EAAM,WAAW,CACjB,EAAM,WAAW,EAGnB,MAAO,UACL,8BACA,EACA,WAAY,EAAM,UAAU,CAC5B,cAAe,EAAM,aAAa,CAClC,WAAY,EAAM,UAAU,CAC5B,WAAY,EAAM,UAAU,CAC5B,YAAa,EAAM,WAAW,CAC9B,YAAa,EAAM,WACrB,AADgC,CAElC,EChH6C,SAKlC,CAAC,CAHqB,YAA3B,OAAO,EACH,MAAM,EAAgB,CAAE,gBAAiB,CAAwB,GACjE,CAAA,GACiB,EAAA,AAAE,EAAE,GAAG,CAAC,CAAC,EAAM,IAAW,EAC/C,EAD8C,CAC1C,CAAC,QAAQ,EAAE,EAAA,CAAO,CACtB,OAAQ,QACR,GAAG,CAAI,CACT,CAAC,EACA,GAEG,EAAgB,CAAC,EAAsB,EAAuB,KAClE,IAAM,EAAgC,CACpC,GAAI,CAAC,IAAI,EAAE,EAAM,OAAO,CAAA,CAAE,SAC1B,EACA,QACF,EAMA,OALI,IACF,EAAI,KADS,IACA,CAAG,CAAA,EAElB,EAAM,OAAO,EAAI,EAEV,CACT,EAGM,EAAiB,EAAA,OAAK,CAAC,OAAO,CAAC,KACnC,IAAM,EAAqC,EAAE,CAoB7C,OAlBA,EAAS,OAAO,CAAC,AAAC,UAEhB,IAAM,EA5EH,MAAM,KA4EU,EA5EH,CADF,AACG,EA2EI,EAAS,AA5EH,EA4EU,AACV,EADmB,OAAO,EAAI,EAAS,OAAO,EA3EhD,EAAO,CAAC,EAAK,CA8EtC,EAAW,OAAO,CAAC,CAAC,EAAW,KAC7B,IAAI,EAAM,EAAS,EAAE,CACjB,EAAW,MAAM,CAAG,GAAG,CACzB,EAAM,CAAA,EAAG,EAAI,CAAC,EAAE,EAAA,CAAA,AAAgB,EAGlC,EAAK,IAAI,CAAC,CACR,GAAI,EACJ,QAAS,EACT,OAAQ,EAAS,MAAM,AACzB,EACF,EACF,GAEO,CACT,EAAG,CAAC,EAAS,EAGP,EAAsB,AAAC,GAC3B,EAAK,MAAM,CAAC,AAAC,GAAS,AAAgB,cAAX,MAAM,EAAgB,GAAG,CAAC,AAAC,GAAS,EAAK,OAAO,EAE7E,GAAU,kBAAkB,IACnB,EAAoB,MAE7B,EAAkB,OAAO,CAAG,GAAU,QAItC,IAAM,EAAiB,CACrB,EACA,KAMA,GAAI,CAAC,EACH,OAEF,CAHe,EAGT,YAAE,CAAU,CAAE,QAAM,CAAE,CAAG,GAAQ,CAAC,EACpC,EAAmD,KACjD,EAAe,EAAS,qBAAqB,CAAC,GAC9C,EAAW,CAAC,MAAM,OAAO,CAAC,GAAgB,EAAe,CAAC,EAAa,EAAE,GAAG,CAAC,AAAC,GAClF,EAAc,EAAS,QAAS,GAAM,YAEpC,GACF,EAAe,EACf,CAFU,CAEE,AAAC,IACX,IAAM,EAAe,IAAI,EAAI,CAC7B,GAAI,EAAoB,CACtB,IAAI,EAGF,EAFE,AAA8B,YAAY,OAAnC,EAES,EAChB,EACA,CACE,SAAU,EAAoB,EAChC,GAGe,EAEnB,EAAa,OAAO,CAAC,AAAC,IAChB,EAAK,EAAE,GAAK,IACd,EAAK,MADqB,AACf,CAAG,UACd,EAAK,OAAO,CAAG,EACX,GAAM,WAAW,CACnB,EAAK,SAAS,CAAG,GAAM,SAAA,EAG7B,EACF,CACA,OAAO,CACT,IAGA,EAAY,AAAC,IACX,IAAI,EAAe,IAAI,KAAQ,EAAS,CACxC,GAAI,EAAoB,CAatB,IAAM,EAAa,EAXe,YAWD,AAXa,AAA1C,OAAO,EAES,EAChB,EACA,CACE,SAAU,EAAoB,EAChC,GAGe,EAE8B,WACjD,EAAe,EAAW,EAAE,CAE5B,EAAe,IAAI,EAAc,EAAW,AAC9C,CAEA,OAAO,CACT,GAIF,IAAI,EAAoD,KAClD,EAAgB,CACpB,EACA,EACA,EACA,KAEA,IAAI,EAAM,IAAc,IAAI,CAAC,AAAC,GAAS,EAAK,EAAE,GAAK,GAoDnD,OAnDK,AAmDE,EArBL,EAAY,AAAC,CA9BL,EA+BC,EAAI,GAAG,CAAC,AAAC,IACd,GAAI,EAAK,EAAE,GAAK,EAAe,CAC7B,IAAM,EAAgB,EAAS,gBAAgB,CAAC,CAC9C,cAAe,EAAK,OAAO,OAC3B,SACA,SACA,kBACA,CACF,GACA,MAAO,CACL,GAAG,CAAI,CACP,QAAS,EACT,QACF,CACF,CACA,OAAO,CACT,IA9CE,GAAU,GACZ,EAAM,IAAc,GADI,CACA,CAAC,AAAC,GAAS,EAAK,EAAE,GAAK,EAAA,IAE7C,EAAI,MAAM,CAAG,EACb,EAAI,OAAO,CAAG,EAAS,gBAAgB,CAAC,OAAE,SAAO,SAAQ,EAAQ,iBAAgB,GACjF,EAAY,AAAC,GACJ,IAAI,EAAI,EAEjB,EAAgB,EAAI,EAAE,GAUxB,EAAM,EANgB,EAAS,UAMX,MAN2B,CAAC,OAC9C,SACA,SACA,kBACA,CACF,GACmC,GACnC,EAAa,AAAD,GAIH,IAHmB,EAAI,MAAM,CAClC,AAAC,GAAqD,EAAK,EAAE,GAAK,GAEtC,EAAK,EAErC,EAAgB,EAAI,EAAE,EAwB1B,EAAM,IAAc,IAAI,CAAC,AAAC,GAAS,EAAK,EAAE,GAAK,IAAkB,CAEnE,EACA,EAAS,aAAa,CAAC,CACrB,SAAU,CAAC,EAAe,IACZ,EAAc,WAAY,EAAO,EAAE,CAAE,GAGnD,UAAW,CAAC,EAAkB,KAC5B,GAAgB,GAChB,GAAmB,EAAgB,MAAM,CAAC,GAC9B,EAAc,eAAW,EAAqB,EAAQ,IAGpE,QAAS,MAAO,EAAc,SAGxB,EACJ,GAHA,GAAgB,GAChB,GAAmB,EAAgB,MAAM,CAAC,GAEtC,EAAiB,CAEnB,GAAI,AAA2B,mBAApB,EAAgC,CAEzC,IAAM,EA5JiB,EAAoB,KA6JrC,EADW,AACL,IAAc,IAAI,CAC5B,AAAC,GAAS,EAAK,EAAE,GAAK,GAAgB,EAAK,EAAE,GAAK,GAGpD,EAAc,MACZ,EACA,EAAe,CACf,kBACA,EACA,YAAa,WACb,CACF,EACF,MACE,CADK,CACS,EAEhB,EAAY,AAAC,GAAoC,IAC5C,EAAI,MAAM,CACX,AAAC,GACC,EAAK,EAAE,GAAK,GAAgB,EAAK,EAAE,GAAK,GAE5C,EAAc,EAA4B,eAAf,EAAM,IAAI,CAAoB,QAAU,SACpE,CACH,MAEE,CAFK,CAES,IAAc,IAAI,CAC7B,AAAD,GAAU,EAAK,EAAE,GAAK,GAAgB,EAAK,EAAE,GAAK,GAEpD,EAAY,AAAC,GACJ,EAAI,GAAG,CAAC,AAAC,GACd,AAAI,EAAK,EAAE,GAAK,GAAgB,EAAK,EAAE,GAAK,EACnC,CACL,GAAG,CAAI,CACP,OAAuB,AAHgC,eAG/C,EAAM,IAAI,CAAoB,QAAU,OAClD,EAEK,IAIb,OAAO,CACT,CACF,GACA,GAAgB,GAChB,GAAmB,EAAgB,GAAG,CAAC,GAAiB,GACxD,EAAS,OAAO,CAAC,GAAG,CAAC,EAAS,eAAe,CAAC,EAAe,EAAS,OAAO,CAAC,OAAO,EACvF,EA2BA,MAAO,CACL,UA1BgB,EAAS,CAAC,EAA+B,KACzD,GAAI,CAAC,EACH,MAAM,AAAI,EADG,IACG,wBAElB,EAAe,EAAe,EAChC,GAsBE,uCACA,iBACA,cACA,gBACA,aACA,EACA,MAAO,KACL,GAAI,CAAC,EACH,MAAM,AAAI,EADG,IACG,wBAElB,EAAkB,OAAO,EAAE,OAC7B,EACA,aAAc,EAAkB,GAAiB,IAAI,KAAoB,EAAQ,EACjF,SAjCe,CACf,EACA,EACA,KAEA,GAAI,CAAC,EACH,MAAU,AAAJ,EADO,IACG,wBAElB,GAAI,CAAC,GAAM,CAAC,IAAc,IAAI,CAAC,AAAC,GAAS,EAAK,EAAE,GAAK,GACnD,EADwD,IAClD,AAAI,MAAM,CAAC,SAAS,EAAE,EAAG,cAAc,CAAC,EAEhD,EAAe,EAAe,CAC5B,WAAY,EACZ,QAAQ,EACR,UAAW,GAAM,SACnB,EACF,CAkBA,CACF,CCxaO,IAAM,EAA0B,CACrC,uBAAwB,IAAI,IAC5B,IAAK,CAAC,EAAa,KACjB,EAAwB,sBAAsB,CAAC,GAAG,CAAC,EAAK,EAC1D,EACA,OAAS,AAAD,IACN,EAAwB,sBAAsB,CAAC,MAAM,CAAC,EACxD,EACA,gBAAiB,AAAC,IAChB,IAAK,IAAM,KAAS,EAAwB,sBAAsB,CAAC,MAAM,GAAI,AAC3E,GAAI,EAAO,CACT,IAAM,EAAe,EAAM,eAAe,CAAC,GAC3C,GAAI,EACF,OAAO,CAEX,CAEJ,CACF,CAEO,CARmB,MAQb,EACH,cAAoC,EAAE,AAAC,CACvC,UAA4B,EAAE,AAAC,CAC/B,QAAiB,CACjB,qBAA8B,CAE9B,eAAgB,CACtB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,AAAC,IACtB,GACF,EACF,CAEA,YAAY,CAAwC,CAAE,CAAoC,CAAE,CAC1F,IAAI,CAAC,gBAAgB,CAAC,GACtB,IAAI,CAAC,QAAQ,CAAG,KAAK,MAAM,GAAG,QAAQ,GACtC,EAAwB,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAE,IAAI,EAC/C,IAAI,CAAC,qBAAqB,CAAG,CAC/B,CAEA,yBAA2B,AAAC,IAC1B,IAAI,CAAC,qBAAqB,CAAG,EAC7B,IAAI,CAAC,aAAa,IACX,EACP,CACF,iBAAmB,AAAC,IAClB,IAAI,CAAC,aAAa,CAAG,IAAI,EAAK,CAC9B,IAAI,CAAC,aAAa,IACX,EACP,CAEF,gBAAkB,AAAC,GACV,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,AAAC,GAAS,EAAK,GAAG,GAAK,EACtD,CAEF,gBAAkB,CAAC,EAAgC,IAEjD,CADc,GACV,CADc,AACb,CADc,MACP,SADsB,CAAC,EAAa,GAAG,IAEjD,IAAI,CAAC,gBAAgB,CACL,YAAd,EACI,CAAC,KAAiB,IAAI,CAAC,aAAa,CAAC,CACrC,IAAI,IAAI,CAAC,aAAa,CAAE,EAAa,GAEpC,EAGT,CAEF,gBAAkB,CAAC,EAA8B,KAC/C,IAAM,EAAQ,IAAI,CAAC,eAAe,CAAC,SACnC,EAAI,IACF,GADS,IACF,MAAM,CAAC,EAAO,GACrB,IAAI,CAAC,gBAAgB,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,GACtC,EAGX,CAAE,CAEF,mBAAqB,AAAC,IACpB,IAAM,EAAQ,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,AAAC,GAAS,EAAK,GAAG,GAAK,UACpD,AAAd,CAAe,GAAG,CAAd,IACF,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAAO,GACjC,IAAI,CAAC,gBAAgB,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,GACtC,EAGX,CAAE,CAEF,YAAc,AAAC,GACN,EAAwB,WAAW,CAAC,EAC3C,CAEF,YAAc,IACL,IAAI,CAAC,aAAa,AACzB,CAEF,yBAA2B,IAClB,IAAI,CAAC,qBAAqB,AACjC,CAEF,UAAY,AAAC,IACX,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GACb,KACL,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,AAAC,GAAa,IAAa,EACpE,EACA,AAEF,SAAU,KACR,EAAwB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAC9C,CAAE,AACJ,CCtGe,SAAS,EAAkB,CAA2B,EACnE,GAAM,CAAC,EAAM,CAAG,CAAA,EAAA,EAAA,QAAA,AAAQ,EAAC,IACT,IAAI,EAChB,GAAQ,sBAAwB,EAAE,CAClC,GAAQ,8BAAgC,KAkB5C,MAbA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAU,IACD,KACL,EAAM,OAAO,EACf,EACC,EAAE,EASE,CACL,cARoB,CAAA,EAAA,EAAA,oBAAA,AAAoB,EAAC,EAAM,SAAS,CAAE,EAAM,WAAW,CAAE,EAAM,WAAW,EAS9F,sBAR4B,CAQL,AARK,EAAA,EAAA,oBAAA,AAAoB,EAChD,EAAM,SAAS,CACf,EAAM,wBAAwB,CAC9B,EAAM,wBAAwB,EAM9B,yBAA0B,EAAM,wBAAwB,CACxD,gBAAiB,EAAM,eAAe,CACtC,mBAAoB,EAAM,kBAAkB,CAC5C,gBAAiB,EAAM,eAAe,CACtC,gBAAiB,EAAM,eAAe,CACtC,iBAAkB,EAAM,gBAAgB,CACxC,YAAa,EAAM,WAAW,AAChC,CACF,CC5BA,IAAM,EAAgB,AAAC,GAAuC,KAAvB,CAAC,GAAO,EAAA,CAAE,CAAE,IAAI,SAgKvD,SAAS,AAA4B,CAA+B,EAClE,GAAM,gBAAE,CA6CK,AA7CS,iBAAE,CAAe,iBAAE,CAAe,eAAE,CAAa,aAAE,CAAW,CAAE,CAAG,EAEzF,GAAI,CAAC,CAAC,aAA0B,cAAA,CAAc,CAC5C,EAD+C,IACzC,AAAI,MAAM,qEAIlB,IAAM,EA5BR,AA4BwB,SA5Bf,EACP,GAAiC,aAAa,AAA1C,OAAO,kBACT,OAAO,IAAI,kBAGb,IAAM,EAAU,IAAI,YAAY,SAChC,OAAO,IAAI,gBAAgB,CACzB,UAAU,CAAK,CAAE,CAAU,EACzB,EAAW,OAAO,CAAC,EAAQ,MAAM,CAAC,EAAO,CAAE,QAAQ,CAAK,GAC1D,EACA,MAAM,CAAU,EACd,EAAW,OAAO,CAAC,EAAQ,MAAM,GACnC,CACF,EACF,IAgBQ,EACJ,EAII,EACG,WAAW,CAAC,EAJf,CAKG,WAAW,CAAC,GAIf,EACG,WAAW,CAAC,EAJf,CAKG,WAAW,CAzKtB,AAyKuB,SAzKd,AAAY,EA7BY,MA6B8B,EAE7D,IAAI,EAAS,EAFwB,CAIrC,OAAO,IAAI,gBAAgC,CACzC,UAAU,CAAW,CAAE,CAAU,EAI/B,IAAM,EAAQ,CAHd,GAAU,CAAA,EAGW,KAAK,CAAC,GAE3B,EAAM,KAAK,CAAC,EAAG,CAAC,GAAG,OAAO,CAAC,AAAC,IAEtB,EAAc,IAChB,EAAW,CADY,MACL,CAAC,EAEvB,GAGA,EAAS,CAAK,CAAC,EAAM,MAAM,CAAG,EAChC,AADkC,EAElC,MAAM,CAAU,EAEV,EAAc,IAChB,EAAW,GADc,IACP,CAAC,EAEvB,CACF,EACF,EA6ImC,IACxB,WAAW,CA5GtB,AA4GuB,SA5Gd,AAAU,EAtFY,IAsF0B,CAAE,EAjF9B,GAiFgE,EAC3F,EADiC,KAC1B,AADgE,IAC5D,gBAAmC,CAC5C,UAAU,CAAS,CAAE,CAAU,EAG7B,IAAM,EADQ,AACG,EADO,KAAK,CAAC,GACP,MAAM,CAAY,CAAC,EAAK,KAC7C,IAAM,EAAiB,EAAK,OAAO,CAAC,GAEpC,GAAuB,CAAC,GAAG,CAAvB,EAIF,OAHA,QAAQ,IAAI,CACV,CAAC,yBAAyB,EAAE,EAAY,gCAAgC,EAAE,EAAK,EAAE,CAAC,EAE7E,EAIT,IAAM,EAAM,EAAK,KAAK,CAAC,EAAG,GAAgB,IAAI,GAG9C,GAAI,CAAC,EAAc,GAAM,OAAO,EAGhC,IAAM,EAAQ,EAAK,KAAK,CAAC,EAAiB,GAAG,IAAI,GAEjD,MAAO,CAAE,GAAG,CAAG,CAAE,CAAC,EAAI,CAAE,CAAM,CAChC,EAAG,CAAC,GAEiC,GAAG,CAApC,OAAO,IAAI,CAAC,GAAU,MAAM,EAGhC,EAAW,OAAO,CAAC,EACrB,CACF,EACF,EA2EiC,EAAe,IAmB9C,OAfA,CAAM,CAAC,OAAO,aAAa,CAAC,CAAG,kBAC7B,IAAM,EAAS,IAAI,CAAC,SAAS,GAE7B,MAAO,CAAM,CACX,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAAO,IAAI,GAEzC,GAAI,EAAM,MAEL,IAGL,GAHY,GAGN,CAAA,CACR,CACF,EAEO,CACT,EC/MA,IAAM,EAAS,MACb,EACA,KAEA,GAAM,CAAE,MAAO,EAAU,WAAW,KAAK,CAAE,cAAc,CAAC,CAAC,CAAE,GAAG,EAAa,CAAG,EAEhF,GAAuB,YAAnB,AAA+B,OAAxB,EACT,MAAM,AAAI,MAAM,sDAIlB,IAAI,EAA2E,CAC7E,EACA,EACD,CAGoC,YAAY,AAA7C,OAAO,EAAY,SAAS,GAG9B,EAF0B,MAAM,EAAY,EAEhC,OAFyC,IAAI,EAE7C,EAId,IAAI,EAAW,MAAM,KAAW,GAGhC,GAAsC,AAAlC,mBAAO,EAAY,UAAU,CAAiB,CAChD,IAAM,EAAmB,MAAM,EAAY,UAAU,CAAC,GAEtD,GAAI,CAAC,CAAC,aAA4B,QAAA,CAAQ,CACxC,EAD2C,IACrC,AAAI,MAAM,2DAGlB,EAAW,CACb,CAGA,GAAI,CAAC,EAAS,EAAE,CACd,CADgB,KACV,AAAI,MAAM,CAAC,yBAAyB,EAAE,EAAS,MAAM,CAAA,CAAE,EAG/D,GAAI,CAAC,EAAS,IAAI,CAChB,CADkB,KACZ,AAAI,MAAM,+BAIlB,OAAO,CACT,IC2DW,CACP,eAAgB,kBAClB,CAeK,OAAe,EACpB,OAAiB,CACjB,OAAsD,AAEtD,aAAY,CAAe,CAAE,CAAqD,CAAE,CAClF,GAAI,CAAC,GAA8B,UAAnB,OAAO,EAAsB,MAAM,AAAI,MAAM,6BAC7D,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,OAAO,CAAG,GAAW,CAAC,CAC7B,CAUF,CAEO,MAAM,UAIH,EACA,aAA6B,CAE7B,cAAwB,AACxB,aAAa,CAAM,CACnB,oBAA8B,CAC9B,kBAAmB,CAAM,CACzB,eAAkC,CAClC,eAAgB,CAAM,CACtB,SAAU,CAAM,CAChB,gBAAkC,CAClC,WAAa,CAAE,CACf,UAA2C,CAC3C,YAAc,MAAU,AAEhC,KAAW,cAAe,CACxB,OAAO,IAAI,CAAC,aAAa,AAC3B,CAEA,IAAW,WAAY,CACrB,OAAO,IAAI,CAAC,UAAU,AACxB,CAEA,IAAY,UAAU,CAAc,CAAE,CACpC,IAAI,CAAC,UAAU,CAAG,CACpB,CAEA,IAAW,iBAAkB,CAC3B,OAAO,IAAI,CAAC,gBACd,AAD8B,CAG9B,IAAY,gBAAgB,CAAc,CAAE,CAC1C,IAAI,CAAC,gBAAgB,CAAG,CAC1B,CAEA,IAAW,cAAe,CACxB,OAAO,IAAI,CAAC,aACd,AAD2B,CAG3B,IAAW,QAAS,CAClB,OAAO,IAAI,CAAC,OAAO,AACrB,CAEA,YAAY,CAAe,CAAE,CAAqD,CAAE,CAClF,KAAK,CAAC,EAAS,GACf,IAAI,CAAC,OAAO,CAAG,GAAS,SAAU,EAC9B,AAAC,IAAI,CAAC,MAAM,EAAE,AAChB,IAAI,CAAC,IAAI,EAEb,CAEO,IAAI,CAAc,CAAE,QACzB,AAAI,IAAI,CAAC,MAAM,EAAE,AACf,IAAI,CAAC,UAAU,GACf,IAAI,CAAC,gBAAgB,CAAG,EACxB,IAAI,CAAC,IAAI,CAAC,GACH,KAET,QAAQ,IAAI,CAAC,oDACN,EACT,CAEO,OAAQ,CACb,aAAa,IAAI,CAAC,cAAc,EAChC,aAAa,IAAI,CAAC,oBAAoB,EACtC,IAAI,CAAC,eAAe,CAAC,KAAK,EAC5B,CAEQ,KAAK,CAA4B,CAAE,CAAqC,CAAE,CAChF,IAAI,CAAC,eAAe,CAAG,IAAI,gBAC3B,GAAM,WACJ,CAAS,QACT,CAAM,SACN,EAAU,CAAC,CAAC,iBACZ,CAAe,CACf,OAAK,SACL,CAAO,eACP,CAAa,aACb,CAAW,iBACX,CAAe,eACf,CAAa,aACb,CAAW,CACX,GAAG,EACJ,CAAG,IAAI,CAAC,OAAO,CACV,EAAe,OAAO,MAAM,CAChC,CAAC,EACD,GAAyB,CAAC,EAC1B,EACA,GAAgB,CAAC,EAFH,CAIV,EAA8C,CAClD,GAAG,AALkB,CAKN,CACf,OAAQ,OACR,KAAM,KAAK,SAAS,CAAC,CACnB,GAAG,CAAM,CACT,GAAI,GAAe,CAAC,CAAC,AACvB,GACA,OAAQ,CACN,GAAG,CAAM,CACT,GAAG,CAAW,AAChB,EACA,QAAS,EACT,OAAQ,IAAI,CAAC,eAAe,CAAC,MAAM,aACnC,CACF,EACI,GAAW,EAAU,GAAG,CAC1B,IAAI,CAAC,cAAc,CAAG,OAAO,UAAU,CAAC,KACtC,IAAI,CAAC,SAAS,CAAG,GACjB,IAAI,CAAC,aAAa,GAClB,GAAW,UAAU,AAAI,MAAM,gBACjC,EAAG,EAAA,EAEL,IAAI,CAAC,YAAY,GAGjB,IAAI,CAAC,aAAa,CAAG,ADrNV,ECqNgC,IAAI,CAAC,OAAO,CAAE,OACvD,EACA,GAAG,CAAW,AAChB,GACG,IAAI,CAAC,MAAO,IAGX,GAFA,aAAa,IAAI,CAAC,cAAc,EAE5B,IAAI,CAAC,SAAS,CAAE,OAEpB,GAAI,EAAiB,CACnB,IAAI,EAAc,EACa,YAA3B,AAAuC,OAAhC,IACT,EAAc,EAAgB,IAAI,CAAC,OAAO,CAAE,EAAS,QAAO,EAE9D,MAAM,IAAI,CAAC,qBAAqB,CAC9B,EACA,EACA,EACA,EACA,EACA,EACA,GAEF,MACF,CACA,IAAM,EAAc,EAAS,OAAO,CAAC,GAAG,CAAC,iBAAmB,GAE5D,OADiB,AACT,EADqB,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,IAG7C,IAAK,oBACH,MAAM,IAAI,CAAC,kBAAkB,CAC3B,EACA,EACA,EACA,EACA,EACA,GAEF,KAEF,KAAK,mBACH,MAAM,IAAI,CAAC,mBAAmB,CAAsB,EAAU,GAC9D,KACF,SACE,MAAM,AAAI,MAAM,CAAC,2BAA2B,EAAE,EAAY,gBAAgB,CAAC,CAC/E,CACF,GACC,KAAK,CAAC,AAAC,IACN,aAAa,IAAI,CAAC,cAAc,EAChC,IAAI,CAAC,aAAa,GAElB,IAAM,EACJ,aAAiB,OAAS,aAAiB,aACvC,EACA,AAAI,MAAM,kBAEV,EAAkB,GAAW,UAAU,GAE7C,GAAiB,eAAb,EAAI,IAAI,CAAmB,CAC7B,IAAM,EACJ,AAA2B,iBAApB,EAA+B,EAAkB,IAAI,CAAC,OAAO,CAAC,aAAa,CACpF,GAAI,GAAiB,EAAgB,EAAG,CAEtC,GACqC,UAAnC,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,EAC9B,IAAI,CAAC,UAAU,EAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAE1C,CADA,MAGF,aAAa,IAAI,CAAC,UAAU,EAC5B,IAAI,CAAC,UAAU,CAAG,WAAW,KAC3B,IAAM,EAAuC,CAAC,CAC1C,MAA4B,IAArB,IAAI,CAAC,IAA6B,OAAlB,GAEzB,CAAY,CAAC,AAvNT,gBAuNqB,CAAG,IAAI,CAAC,WAAA,AAAW,EAE9C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAE,EACnC,EAAG,GACH,IAAI,CAAC,UAAU,CAAG,IAAI,CAAC,UAAU,CAAG,CACtC,CACF,CACF,EACJ,CAEQ,cAAe,CACrB,IAAI,CAAC,aAAa,EAAG,CACvB,CAEQ,eAAgB,CACtB,IAAI,CAAC,aAAa,EAAG,CACvB,CAEQ,sBAAwB,MAC9B,EACA,EACA,EACA,EACA,EACA,EACA,KAEA,IAAM,EAAS,EAAgB,CAC7B,eAAgB,EAAS,IAAI,iBAC7B,kBACA,EACA,gBACA,aACF,EACA,OAAM,IAAI,CAAC,aAAa,CAAsB,EAAQ,EAAU,EAAW,EAC7E,CAAE,AAEM,oBAAqB,MAC3B,EACA,EACA,EACA,EACA,EACA,KAEA,IAAM,EAAS,EAAgB,CAC7B,eAAgB,EAAS,IAAI,iBAC7B,gBACA,EACA,aACF,EACA,OAAM,IAAI,CAAC,aAAa,CAAsB,EAAQ,EAAU,EAAW,EAC7E,CAAE,AAEF,OAAc,cACZ,CAA+B,CAC/B,CAAkB,CAClB,CAAkD,CAClD,CAAsB,CACtB,CACA,IAEI,EAFE,EAAmB,EAAE,CACrB,EAAW,CAAM,CAAC,OAAO,aAAa,CAAC,GAE7C,EAAG,CAaD,GAVI,IACF,IAAI,CAAC,MADY,cACQ,CAAG,OAAO,UAAU,CAAC,KAC5C,IAAI,CAAC,eAAe,EAAG,EACvB,IAAI,CAAC,aAAa,GAClB,GAAW,UAAU,AAAI,MAAM,2BAAuB,EAAW,EAAS,OAAO,CACnF,EAAG,EAAA,EAGL,EAAS,MAAM,EAAS,IAAI,GAC5B,aAAa,IAAI,CAAC,oBAAoB,EAClC,IAAI,CAAC,eAAe,CACtB,CADwB,KAItB,EAAO,KAAK,EAAE,CAChB,EAAO,IAAI,CAAC,EAAO,KAAK,EACxB,GAAW,WAAW,EAAO,KAAK,CAAE,EAAS,OAAO,EAChD,KAA6B,IAAtB,GAAQ,MAA2B,CAApB,KAExB,IAAI,CAAC,WAAW,CAAG,EAAO,KAAK,CAAC,EAAA,AAAE,EAGxC,OAAS,CAAC,EAAO,IAAI,CAAE,AACvB,AAAI,IACF,WADiB,EACJ,IAAI,CAAC,oBAAoB,EAClC,IAAI,CAAC,eAAe,EAAE,AACxB,IAAI,CAAC,aAAa,IAItB,IAAI,CAAC,aAAa,GAClB,GAAW,YAAY,EAAQ,EAAS,OAAO,EACjD,CAEQ,oBAAsB,MAI5B,EACA,KAEA,IAAM,EAAgB,MAAM,EAAS,IAAI,GAEzC,GAAK,GAAsB,WAAY,EAAO,CAC5C,IAAM,EAAQ,AAAI,MAAO,EAAqB,OAAO,EAAI,eACzD,GAAM,IAAI,CAAI,EAAqB,IAAI,EAAI,cAC3C,GAAW,UAAU,EAAO,EAAO,EAAS,OAAO,CACrD,MACE,CADK,EACM,WAAW,EAAO,EAAS,OAAO,EAC7C,IAAI,CAAC,aAAa,GAElB,GAAW,YAAY,CAAC,EAAM,CAAE,EAAS,OAAO,CAEpD,CAAE,CAEM,YAAa,CACnB,aAAa,IAAI,CAAC,UAAU,EAC5B,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,WAAW,CAAG,MACrB,CACF,kKAEA,SAAS,AACP,CAAe,CACf,CAAqD,EAErD,OAAO,IAAI,EAA0C,EAAS,EAChE","ignoreList":[5,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24]}