import type { AnyObject } from '../_util/type';
import { MessageInfo, SimpleType } from '../x-chat';
import type { SSEOutput, XStreamOptions } from '../x-stream';
import type { XFetchMiddlewares } from './x-fetch';
export interface XRequestCallbacks<Output, ChatMessage extends SimpleType = any> {
    /**
     * @description Callback when the request is successful
     */
    onSuccess: (chunks: Output[], responseHeaders: Headers, chatMessage?: MessageInfo<ChatMessage>) => void;
    /**
     * @description Callback when the request fails
     */
    onError: (error: Error, errorInfo?: any, responseHeaders?: Headers, fallbackMsg?: MessageInfo<ChatMessage>) => void;
    /**
     * @description Callback when the request is updated
     */
    onUpdate?: (chunk: Output, responseHeaders: Headers, chatMessage?: MessageInfo<ChatMessage>) => void;
}
export interface XRequestOptions<Input = AnyObject, Output = SSEOutput, ChatMessage extends SimpleType = any> extends RequestInit {
    /**
     * @description Callbacks for the request
     */
    callbacks?: XRequestCallbacks<Output, ChatMessage>;
    /**
     * @description The parameters to be sent
     */
    params?: Input;
    /**
     * @description The custom headers to be sent
     */
    headers?: Record<string, string>;
    /**
     * @description The timeout for the request
     */
    timeout?: number;
    /**
     * @description The timeout for the stream mode request,when the stream mode request is timeout, the request will be aborted
     */
    streamTimeout?: number;
    /**
     * @description Custom fetch
     */
    fetch?: (baseURL: Parameters<typeof fetch>[0], options: XRequestOptions<Input, Output>) => Promise<Response>;
    /**
     * @description Middlewares for the request and response
     */
    middlewares?: XFetchMiddlewares<Input, Output>;
    /**
     * @description Custom stream transformer, can use to adapt the stream data to the custom format
     */
    transformStream?: XStreamOptions<Output>['transformStream'] | ((baseURL: string, responseHeaders: Headers) => XStreamOptions<Output>['transformStream']);
    /**
     * @description Separator for stream data parsing
     */
    streamSeparator?: string;
    /**
     * @description Separator for different parts within the stream
     */
    partSeparator?: string;
    /**
     * @description Separator for key-value pairs in the stream data
     */
    kvSeparator?: string;
    /**
     * @description Whether to manually run the request
     */
    manual?: boolean;
    /**
     * @description The interval after the request is failed
     */
    retryInterval?: number;
    /**
     * @description Retry times limit, valid when retryInterval is set or onError returns a number
     */
    retryTimes?: number;
}
export type XRequestGlobalOptions<Input, Output> = Pick<XRequestOptions<Input, Output>, 'headers' | 'timeout' | 'streamTimeout' | 'middlewares' | 'fetch' | 'transformStream' | 'manual'>;
export type XRequestFunction<Input = AnyObject, Output = SSEOutput> = (baseURL: string, options?: XRequestOptions<Input, Output>) => XRequestClass<Input, Output>;
/**
 * Set global options for the request
 * @param options XRequestGlobalOptions<Input, Output>
 */
export declare function setXRequestGlobalOptions<Input, Output>(options: XRequestGlobalOptions<Input, Output>): void;
export declare abstract class AbstractXRequestClass<Input, Output, ChatMessage extends SimpleType = any> {
    baseURL: string;
    options: XRequestOptions<Input, Output, ChatMessage>;
    constructor(baseURL: string, options?: XRequestOptions<Input, Output, ChatMessage>);
    abstract get asyncHandler(): Promise<any>;
    abstract get isTimeout(): boolean;
    abstract get isStreamTimeout(): boolean;
    abstract get isRequesting(): boolean;
    abstract get manual(): boolean;
    abstract run(params?: Input): void;
    abstract abort(): void;
}
export declare class XRequestClass<Input = AnyObject, Output = SSEOutput, ChatMessage extends SimpleType = any> extends AbstractXRequestClass<Input, Output, ChatMessage> {
    private _asyncHandler;
    private timeoutHandler;
    private _isTimeout;
    private streamTimeoutHandler;
    private _isStreamTimeout;
    private abortController;
    private _isRequesting;
    private _manual;
    private lastManualParams?;
    private retryTimes;
    private retryTimer;
    private lastEventId;
    get asyncHandler(): Promise<any>;
    get isTimeout(): boolean;
    private set isTimeout(value);
    get isStreamTimeout(): boolean;
    private set isStreamTimeout(value);
    get isRequesting(): boolean;
    get manual(): boolean;
    constructor(baseURL: string, options?: XRequestOptions<Input, Output, ChatMessage>);
    run(params?: Input): boolean;
    abort(): void;
    private init;
    private startRequest;
    private finishRequest;
    private customResponseHandler;
    private sseResponseHandler;
    private processStream;
    private jsonResponseHandler;
    private resetRetry;
}
declare function XRequest<Input = AnyObject, Output = SSEOutput, ChatMessage extends SimpleType = any>(baseURL: string, options?: XRequestOptions<Input, Output, ChatMessage>): AbstractXRequestClass<Input, Output, ChatMessage>;
export default XRequest;
