"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chatMessagesStoreHelper = exports.ChatMessagesStore = void 0;
exports.useChatStore = useChatStore;
var _react = require("react");
const chatMessagesStoreHelper = exports.chatMessagesStoreHelper = {
  _chatMessagesStores: new Map(),
  get: conversationKey => {
    return chatMessagesStoreHelper._chatMessagesStores.get(conversationKey);
  },
  set: (key, store) => {
    chatMessagesStoreHelper._chatMessagesStores.set(key, store);
  },
  delete: key => {
    chatMessagesStoreHelper._chatMessagesStores.delete(key);
  },
  getMessages: conversationKey => {
    const store = chatMessagesStoreHelper._chatMessagesStores.get(conversationKey);
    return store?.getMessages();
  }
};
class ChatMessagesStore {
  listeners = [];
  conversationKey;
  snapshotResult = {
    messages: [],
    isDefaultMessagesRequesting: false
  };
  // Throttle state for preventing "Maximum update depth exceeded" during streaming
  throttleTimer = null;
  pendingEmit = false;
  throttleInterval = 50;
  // 竞态条件保护
  isDestroyed = false;
  emitListeners() {
    this.listeners.forEach(listener => {
      listener();
    });
  }
  throttledEmitListeners() {
    if (!this.throttleTimer) {
      // Leading edge: execute immediately
      this.emitListeners();
      this.pendingEmit = false;
      this.throttleTimer = setTimeout(() => {
        this.throttleTimer = null;
        // Trailing edge: flush pending updates
        if (this.pendingEmit) {
          this.emitListeners();
          this.pendingEmit = false;
        }
      }, this.throttleInterval);
    } else {
      this.pendingEmit = true;
    }
  }
  constructor(defaultMessages, conversationKey) {
    // 初始化消息，处理同步和异步情况
    this.initializeMessages(defaultMessages, value => {
      this.setSnapshotResult('isDefaultMessagesRequesting', value);
      this.emitListeners();
    });

    // 注册到全局存储助手
    if (conversationKey) {
      this.conversationKey = conversationKey;
      chatMessagesStoreHelper.set(this.conversationKey, this);
    }
  }
  async initializeMessages(defaultMessages, setDefaultMessagesRequesting) {
    try {
      setDefaultMessagesRequesting(true);
      const messages = await defaultMessages();

      // 检查是否已被销毁，避免竞态条件
      if (!this.isDestroyed) {
        this.setMessagesInternal(messages, false);
      }
    } catch (error) {
      // 错误处理：保持空数组状态，避免应用崩溃
      console.warn('Failed to initialize messages:', error);
      if (!this.isDestroyed) {
        this.setMessagesInternal([], false);
      }
    } finally {
      setDefaultMessagesRequesting(false);
    }
  }
  setSnapshotResult = (key, value) => {
    this.snapshotResult = {
      ...this.snapshotResult,
      [key]: value
    };
  };
  setMessagesInternal = (messages, throttle = true) => {
    let list;
    if (typeof messages === 'function') {
      list = messages(this.snapshotResult.messages);
    } else {
      list = messages;
    }
    this.setSnapshotResult('messages', list);
    if (throttle) {
      this.throttledEmitListeners();
    } else {
      this.emitListeners();
    }
    return true;
  };
  setMessages = messages => {
    return this.setMessagesInternal(messages, true);
  };
  getMessages = () => {
    return this.snapshotResult.messages;
  };
  getMessage = id => {
    return this.getMessages().find(item => item.id === id);
  };
  addMessage = message => {
    const exist = this.getMessage(message.id);
    if (!exist) {
      this.setMessages([...this.snapshotResult.messages, message]);
      return true;
    }
    return false;
  };
  setMessage = (id, message) => {
    const originMessage = this.getMessage(id);
    if (originMessage) {
      const mergeMessage = typeof message === 'function' ? message(originMessage) : message;
      Object.assign(originMessage, mergeMessage);
      this.setMessages([...this.snapshotResult.messages]);
      return true;
    }
    return false;
  };
  removeMessage = id => {
    const index = this.getMessages().findIndex(item => item.id === id);
    if (index !== -1) {
      this.snapshotResult.messages.splice(index, 1);
      this.setMessages([...this.getMessages()]);
      return true;
    }
    return false;
  };
  getSnapshot = () => {
    return this.snapshotResult;
  };
  subscribe = callback => {
    this.listeners.push(callback);
    return () => {
      this.listeners = this.listeners.filter(listener => listener !== callback);
      // Clean up throttle timer when no listeners remain to prevent memory leaks
      // and "setState on unmounted component" warnings
      if (this.listeners.length === 0) {
        if (this.throttleTimer) {
          clearTimeout(this.throttleTimer);
          this.throttleTimer = null;
        }
        this.pendingEmit = false;
      }
    };
  };

  /**
   * Clean up resources (throttle timer) when the store is no longer needed.
   * Should be called when the component unmounts or the store is disposed.
   */
  destroy = () => {
    this.isDestroyed = true;
    if (this.throttleTimer) {
      clearTimeout(this.throttleTimer);
      this.throttleTimer = null;
    }
    this.pendingEmit = false;
    this.listeners = [];
  };
}
exports.ChatMessagesStore = ChatMessagesStore;
function useChatStore(defaultValue, conversationKey) {
  const createStore = () => {
    if (chatMessagesStoreHelper.get(conversationKey)) {
      return chatMessagesStoreHelper.get(conversationKey);
    }
    const store = new ChatMessagesStore(defaultValue, conversationKey);
    return store;
  };
  const [store, setStore] = (0, _react.useState)(createStore);
  (0, _react.useEffect)(() => {
    setStore(createStore());
  }, [conversationKey]);
  const {
    messages,
    isDefaultMessagesRequesting
  } = (0, _react.useSyncExternalStore)(store.subscribe, store.getSnapshot, store.getSnapshot);
  return {
    messages,
    isDefaultMessagesRequesting,
    addMessage: store.addMessage,
    removeMessage: store.removeMessage,
    setMessage: store.setMessage,
    getMessage: store.getMessage,
    setMessages: store.setMessages,
    getMessages: store.getMessages
  };
}