"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _katex = _interopRequireDefault(require("katex"));
require("katex/dist/katex.min.css");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const inlineRuleNonStandard = /^(?:\${1,2}([^$]{1,10000}?)\${1,2}|\\\(([\s\S]{1,10000}?)\\\)|\\\[((?:\\.|[^\\]){1,10000}?)\\\])/;
const blockRule = /^(\${1,2})\n([\s\S]{1,10000}?)\n\1(?:\n|$)|^\\\[((?:\\.|[^\\]){1,10000}?)\\\]/;
// fix katex not support align*: https://github.com/KaTeX/KaTeX/issues/1007
function replaceAlign(text) {
  return text ? text.replace(/\{align\*\}/g, '{aligned}') : text;
}
function createRenderer(options, newlineAfter) {
  return token => _katex.default.renderToString(token.text, {
    ...options,
    displayMode: token.displayMode
  }) + (newlineAfter ? '\n' : '');
}
function inlineKatex(renderer, replaceAlignStart) {
  return {
    name: 'inlineKatex',
    level: 'inline',
    start(src) {
      const dollarIndex = src.indexOf('$');
      const parenIndex = src.indexOf('\\(');
      const bracketIndex = src.indexOf('\\[');
      const indices = [dollarIndex, parenIndex, bracketIndex].filter(idx => idx !== -1);
      return indices.length > 0 ? Math.min(...indices) : undefined;
    },
    tokenizer(src) {
      const match = src.match(inlineRuleNonStandard);
      if (!match) return;
      const rawText = (match[1] || match[2] || match[3] || '').trim();
      const text = replaceAlignStart ? replaceAlign(rawText) : rawText;
      return {
        type: 'inlineKatex',
        raw: match[0],
        text,
        displayMode: true
      };
    },
    renderer: token => `<span class="inline-katex">${renderer(token)}</span>`
  };
}
function blockKatex(renderer, replaceAlignStart) {
  return {
    name: 'blockKatex',
    level: 'block',
    tokenizer(src) {
      const match = src.match(blockRule);
      if (match) {
        let text = replaceAlign(match[2] || match[3].trim());
        if (replaceAlignStart) {
          text = replaceAlign(text);
        }
        return {
          type: 'blockKatex',
          raw: match[0],
          text,
          displayMode: true
        };
      }
    },
    renderer
  };
}
const Latex = options => {
  const {
    replaceAlignStart = true,
    katexOptions: customKatexOptions
  } = options || {};
  const katexOptions = {
    output: 'html',
    throwOnError: false,
    ...(customKatexOptions || {})
  };
  const inlineRenderer = createRenderer(katexOptions, true);
  const blockRenderer = createRenderer(katexOptions, true);
  return [inlineKatex(inlineRenderer, replaceAlignStart), blockKatex(blockRenderer, replaceAlignStart)];
};
var _default = exports.default = Latex;